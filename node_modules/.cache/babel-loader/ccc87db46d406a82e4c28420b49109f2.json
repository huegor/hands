{"ast":null,"code":"var _jsxFileName = \"/Users/skye/Desktop/Portfolio/2021/chronologies/client/src/components/Graphic.js\",\n    _s = $RefreshSig$();\n\nimport React, { useState, useEffect, useRef } from 'react';\nimport { select, scaleLinear, scaleOrdinal, axisBottom, axisLeft, linkHorizontal, format, drag, zoom, min, max, symbol, symbols } from \"d3\";\nimport useResizeObserver from \"./useResizeObserver\";\nimport generateIntervals from \"./generateIntervals\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nfunction Graphic({\n  data,\n  setData,\n  activeLayer,\n  zones,\n  setZones,\n  radius,\n  info,\n  setInfo,\n  setInflectTarget,\n  showLabel,\n  toggle,\n  setToggle,\n  scales,\n  setScales,\n  syntacticOrder,\n  setSyntacticOrder,\n  activeScale\n}) {\n  _s();\n\n  //all data is passed down from and synced to App.js\n  const activeData = Object.entries(data); //convert json to array for faster processing\n\n  const activeZones = Object.entries(zones); //TODO: layers\n  // const activeData = activeLayer ? Object.entries(data).filter(([k,v]) => v.layer === activeLayer) : arrayData;\n  //convert scale object to array for faster processing\n  //is logical operators active?\n\n  const logic = data.length ? isNaN(data[0].x) : null; //TODO: refine logical operators\n  //initialize reference object to pass to svg in React Dom\n\n  const svgRef = useRef(); //svg wrapped in div bc otherwise resize observer callback won't work\n\n  const wrapperRef = useRef();\n  const dimensions = useResizeObserver(wrapperRef);\n  const [currentZoomState, setCurrentZoomState] = useState(); //hash map of y scales\n\n  const yScales = {}; //init scales\n\n  useEffect(() => {\n    if (!dimensions) return;\n    Object.entries(scales.y).forEach(([k, v]) => {\n      yScales[k] = {\n        scale: scaleLinear().domain([0, dimensions.height]).range([v.min, v.max]),\n        inverse: scaleLinear().domain([v.min, v.max]).range([0, dimensions.height]),\n        drag: scaleLinear().domain([-dimensions.height, dimensions.height]).range([-(v.max - v.min), v.max - v.min])\n      };\n    });\n  }, [dimensions, scales, currentZoomState]); //initialize intervals between instants\n\n  const intervals = generateIntervals(data); //TODO: write updateIntervals function\n  //initialize variables\n\n  /*\n  var xMin = min(Object.entries(data).map(([key, {x}]) => logic ? logicScale(x) : x));\n  var xMax = max(Object.entries(data).map(([key, {x}]) => logic ? logicScale(x) : x));\n  var yMin = min(Object.entries(data).map(([key, {y}]) => y));\n  var yMax = max(Object.entries(data).map(([key, {y}]) => y));\n  */\n  //all d3 shennanigans goes in this hook. called initially and on every data change\n\n  useEffect(() => {\n    const svg = select(svgRef.current); //\"svg\" is the current version of svgRef data\n    //prevents crashing when useResizeObserver returns null before svg is rendered\n\n    if (!dimensions) return; //removes svgs added using append()\n\n    svg.selectAll(\".remove\").remove(); //rounding for data inputted thru paintbox interface\n\n    function round(value, range) {\n      const precision = Math.log10(range) < 1 ? -Math.floor(Math.log10(range) - 1) : 0;\n      return Math.round(value * Math.pow(10, precision)) / Math.pow(10, precision);\n    } //---scales---//\n    //if time matches logical operator keyword, translate into index values, then map\n\n\n    const logicScale = scaleOrdinal([\"before\", \"now\", \"after\"], [-1, 0, 1]).unknown(0);\n    const breakpoint = 5;\n    const xMin = min(Object.entries(data).map(([key, {\n      x\n    }]) => logic ? logicScale(x) : x));\n    const xMax = max(Object.entries(data).map(([key, {\n      x\n    }]) => logic ? logicScale(x) : x)); // const yMin = min(Object.entries(data).map(([key, {y}]) => y));\n    // const yMax = max(Object.entries(data).map(([key, {y}]) => y));\n\n    const yMin = scales.y[Object.keys(scales.y)[0]].min; //TODO: right now it onselects first y scale\n\n    const yMax = scales.y[Object.keys(scales.y)[0]].max;\n    const rangeX = xMax - xMin; //0 is minX, 1 is maxX (reference findMinMax)\n\n    const rangeY = yMax - yMin;\n    /*\n    - Allow users to specify scale. x&y min max and units label\n    - for each scale, generateScale()\n    */\n    // function generateScales(currentScale) { //TODO: turn into dedicated scaleDrag\n    //\n    //   const xInverse = scaleLinear()\n    //     .domain([0, dimensions.width])\n    //     .range([currentScale.min, currentScale.max]) //maxRangeX-minRangeX gives section of x values displayed onscreen\n    //   const xDrag = scaleLinear()\n    //     .domain([-dimensions.width, dimensions.width])\n    //     .range([-(currentScale.domain()[1]-currentScale.domain()[0]), (currentScale.domain()[1]-currentScale.domain()[0])]) //maxRangeX-minRangeX gives section of x values displayed onscreen\n    //   const yInverse = scaleLinear()\n    //     .domain([-dimensions.height, dimensions.height])\n    //     .range((rangeY>breakpoint) ? [-rangeY, rangeY] : [-breakpoint*5, breakpoint*5])\n    //\n    //\n    //   return {\n    //     xInverse, xDrag, yInverse\n    //   };\n    // }\n\n    const xInverse = currentScale => scaleLinear().domain([0, dimensions.width]).range([currentScale.min, currentScale.max]); //maxRangeX-minRangeX gives section of x values displayed onscreen\n\n\n    const xDrag = currentScale => scaleLinear().domain([-dimensions.width, dimensions.width]).range([-(currentScale.domain()[1] - currentScale.domain()[0]), currentScale.domain()[1] - currentScale.domain()[0]]); //maxRangeX-minRangeX gives section of x values displayed onscreen\n    // const yInverse = scaleLinear()\n    //   .domain([-dimensions.height, dimensions.height])\n    //   .range((rangeY>breakpoint) ? [-rangeY, rangeY] : [-breakpoint*5, breakpoint*5])\n    //scales values to screen pixels\n\n    /*\n    {\n      biggie: {\n        ...\n        scale: generateScale()\n      }\n      ...\n    }\n    */\n\n    /*\n    xScale =\n    {\n    }\n    */\n    // const xScales1 = Object.entries(scales).map(([key, thisScale]) => [\n    //     key,\n    //     {\n    //       scale: scaleLinear() //scaleLinear takes domain (data values) & maps onto range (screen pixel values)\n    //         .domain([thisScale.min, thisScale.max])\n    //         .range([0, dimensions.width]),\n    //       hasSegments: thisScale.segments.length?true:false,\n    //       yPos: thisScale.yPos,\n    //       label: thisScale.label,\n    //       tickValues: thisScale.tickValues?thisScale.tickValues:null\n    //     }\n    //   ]);\n    //   console.log(xScales1)\n    //TODO: fromEntries & entries not compatible with some older browsers\n\n\n    const xScales = Object.fromEntries( //for every scale in scales data, generate an xScale\n    Object.entries(scales.x).map(([key, thisScale]) => [key, {\n      scale: scaleLinear() //scaleLinear takes domain (data values) & maps onto range (screen pixel values)\n      .domain([thisScale.min, thisScale.max]).range([0, dimensions.width]),\n      hasSegments: thisScale.segments.length ? true : false,\n      hideLabel: thisScale.hideLabel,\n      yPos: thisScale.yPos,\n      label: `${key} (${thisScale.label})`,\n      tickValues: thisScale.tickValues ? thisScale.tickValues : null,\n      scaleInverse: scaleLinear() //for NewInstantForm\n      .domain([0, dimensions.width]).range([thisScale.min, thisScale.max])\n    }]));\n\n    const xSegments = () => {\n      const segments = [];\n      Object.keys(scales.x).forEach((key, i) => {\n        const thisScale = scales.x[key]; // const segments = [];\n\n        if (!thisScale.segments.length) {\n          return;\n        }\n\n        thisScale.segments.map(n => {\n          const min = n.min ? n.min : thisScale.min; //if segment contains a min, set that as min. otherwise, set scale min as min.\n\n          const max = n.max ? n.max : thisScale.max; // console.log(xScales[i].scale(min));\n\n          segments.push({\n            scale: key,\n            yPos: thisScale.yPos,\n            proportion: (max - min) / (thisScale.max - thisScale.min),\n            segment: scaleLinear().domain([min, max]).range([xScales[key].scale(min), xScales[key].scale(max)])\n          });\n        });\n      });\n      return segments;\n    };\n    /*\n      xScales(generateScales(scaleLinear(scale)))\n      - take xScale and rescale according to transformations (newXScale)\n      - update each array entry's domain with that of newXScale\n    */\n    //if there is a zoom transform, override each xScales.scale with adjusted scale\n\n\n    if (currentZoomState) {\n      Object.entries(xScales).forEach(([key, thisScale]) => {\n        const newXScale = currentZoomState.rescaleX(thisScale.scale); //zoom state comes w methods for transformations\n\n        const newMin = newXScale.domain()[0];\n        const newMax = newXScale.domain()[1]; //applies zoom transformations to scale + scaleInverse\n\n        xScales[key].scale = newXScale;\n      });\n    }\n\n    ; // const xScale = scaleLinear()\n    //   .domain([xMin, xMax]) //scaleLinear takes domain (data values) & maps onto range (screen pixel values)\n    //   .range([0, dimensions.width]);\n\n    const yScale = scaleLinear() //if difference in y vaules greater than 5, resize to min and max\n    // .domain((rangeY>breakpoint) ? [yMin, yMax] : [yMin-breakpoint, yMax+breakpoint])\n    .domain([yMin, yMax]).range([0, dimensions.height]); //inverse scales for drag behavior\n    // const xScaleInverse = scaleLinear()\n    //   .domain([-dimensions.width, dimensions.width])\n    //   .range([-rangeX, rangeX]); //maxRangeX-minRangeX gives section of x values displayed onscreen\n\n    const yScaleInverse = scaleLinear().domain([0, dimensions.height]).range([yMin, yMax]); // .range((rangeY>breakpoint) ? [yMin, yMax] : [yMin-breakpoint, yMax+breakpoint]);\n\n    const yScaleInverseDrag = scaleLinear().domain([-dimensions.height, dimensions.height]).range([-rangeY, rangeY]); // .range((rangeY>breakpoint) ? [-rangeY, rangeY] : [-breakpoint*5, breakpoint*5]);\n    //---draw zones---//\n\n    if (activeZones.length) {\n      svg.selectAll(\".zones\").data(activeZones).join(\"rect\").attr(\"class\", \"zones\").attr(\"x\", ([k, v]) => xScales[v.scale[0]].scale(v.start)) // .attr(\"x\", n => generateScales(scales[n.scale]).x(n.start))\n      // .attr(\"y\", n => n.yStart ? yScale(n.yStart) : yScale(minMax[2]))\n      .attr(\"y\", ([k, v]) => v.yStart ? yScale(v.yStart) : yMin - 10) //TODO: if no yStart, minimum y value\n      .attr(\"width\", ([k, v]) => xScales[v.scale[0]].scale(v.end) - xScales[v.scale[0]].scale(v.start)).attr(\"height\", ([k, v]) => {\n        if (v.yStart & v.yEnd) {\n          return yScale(v.yEnd) - yScale(v.yStart);\n        } else if (v.yStart) {\n          return yScale(yMax + 10) - yScale(v.yStart);\n        } else {\n          return yScale(yMax + 10); //TODO: if no yStart, minimum y value\n          // return (yScale(minMax[3])-yScale(minMax[2]))\n        }\n      }).attr(\"opacity\", ([k, v]) => v.opacity ? v.opacity : 0.5).attr(\"fill\", ([k, v]) => v.color ? v.color : \"#999\").attr(\"stroke\", \"black\") //TODO: stroke be different colors\n      .attr(\"stroke-width\", ([k, v]) => v.importance ? v.importance * 2 : 0).on(\"click\", (e, target) => {\n        if (toggle === \"certainty\" || toggle === \"importance\") {\n          //pulls up inflection menu\n          setInflectTarget(target);\n        } else {\n          //displays zone properties when clicked\n          setInfo(null); //clear InfoBox\n\n          setInfo({\n            position: [e.x, e.y],\n            target: target,\n            type: \"zone\"\n          }); //TODO: set info to null when clicking same zone again\n        }\n\n        e.stopPropagation();\n      });\n    } //---draw bottom axis---//\n\n\n    xSegments().forEach(n => {\n      const segment = axisBottom(n.segment) // .ticks(n.proportion<.33?5:null, \"f\");\n      .ticks(null, \"f\").tickSize(-dimensions.height);\n      svg.append(\"g\").attr(\"class\", \"remove\").style(\"transform\", `translateY(${dimensions.height * n.yPos}px)`).call(segment).raise().call(g => g.select(\".domain\") //removes solid black axis bar\n      .remove()).call(g => g.selectAll(\".tick line\") //styles individual ticks\n      .attr(\"stroke-opacity\", 0.25)).call(g => g.selectAll(\".tick text\").attr(\"y\", 10).attr(\"opacity\", (d, i) => {\n        //TODO: remove instead of setting opacity to 0\n        if (n.proportion < .25 && i % 3) {\n          //less than 1/4, label every 3 ticks\n          return 0;\n        } else if (n.proportion < .33 && i % 2) {\n          //less than 1/3, label every other tick\n          return 0;\n        } else {\n          return 0.5;\n        }\n      }));\n    });\n    Object.entries(xScales).forEach(([key, thisScale]) => {\n      const xAxis = axisBottom(thisScale.scale).tickValues(thisScale.tickValues).tickFormat(format('')).tickSize(-dimensions.height);\n\n      if (!thisScale.hasSegments || thisScale.tickValues) {\n        svg.append(\"g\").attr(\"class\", \"remove\").style(\"transform\", `translateY(${dimensions.height * thisScale.yPos}px)`).call(xAxis).raise().call(g => g.select(\".domain\") //removes solid black axis bar\n        .remove()).call(g => g.selectAll(\".tick line\") //styles individual ticks\n        .attr(\"stroke-opacity\", 0.25)).call(g => g.selectAll(\".tick text\").attr(\"y\", 10) //TODO: dynamic tick text spacing for accessibility\n        .attr(\"opacity\", 0.5));\n      }\n\n      if (!thisScale.hideLabels) {\n        svg.append(\"text\").text(thisScale.label).attr(\"class\", \"axisLabel smallTxt remove\").attr(\"x\", dimensions.width / 2).attr(\"y\", dimensions.height * (thisScale.yPos + .07)).attr(\"text-anchor\", \"middle\").attr(\"opacity\", 0.5);\n      }\n    }); //--draw vertical axis--//\n\n    const yAxis = axisLeft(yScale).tickValues(scales.y[Object.keys(scales.y)[0]].min, scales.y[Object.keys(scales.y)[0]].max);\n    svg.append(\"g\").attr(\"class\", \"remove\") // .style(\"transform\", `translateY(${dimensions.height*thisScale.yPos}px)`)\n    .call(yAxis).raise().call(g => g.select(\".domain\") //removes solid black axis bar\n    .remove()).call(g => g.selectAll(\".tick line\") //styles individual ticks\n    .attr(\"stroke-opacity\", 0.5)).call(g => g.selectAll(\".tick text\").attr(\"y\", 10) //TODO: dynamic tick text spacing for accessibility\n    .attr(\"opacity\", 0.5)); //--drag behavior--//\n\n    const dragged = drag() // .on(\"start\", e => {\n    //   select(this).attr(\"stroke\", \"black\");\n    // })\n    .on(\"drag\", e => {\n      //TODO: extract precision function to round new pos\n      const dx = xDrag(xScales[e.subject[1].scale[0]].scale)(e.dx); // const dx = xScales.scaleInverse\n\n      const dy = yScaleInverseDrag(e.dy);\n      const newInstants = { ...data\n      }; //always make a copy when updating array\n      //find array element in data with matching ID and set new x y coordinates\n\n      newInstants[e.subject[0]].x += dx;\n      newInstants[e.subject[0]].y += dy;\n      setData(newInstants);\n    });\n\n    if (Object.entries(data).length) {\n      //---draw intervals---//\n      const intervaler = linkHorizontal().source(interval => interval.source[1]).target(interval => interval.target[1]) // .x(n => generateScales(scales[n.scale]).x(logic ? logicScale(n.x) : n.x))\n      .x(d => xScales[d.scale[0]].scale(d.x)).y(d => yScale(d.y));\n      svg.selectAll(\".interval\").data(intervals).join(\"path\").raise().attr(\"class\", \"interval pointer\").attr(\"d\", intervaler).attr(\"fill\", \"none\").attr(\"stroke\", n => n.color ? n.color : \"black\").attr(\"stroke-width\", n => n.width ? n.width : radius / 2).attr(\"stroke-opacity\", n => n.opacity ? n.opacity : 1).attr(\"stroke-dasharray\", n => n.dashed ? n.dashed : null).on(\"click\", (e, target) => {\n        if (toggle === \"connection\") {\n          const newOrder = [...syntacticOrder];\n\n          if (newOrder[2] === 0) {\n            //set 2nd selection\n            newOrder[1] = {\n              x: xInverse(scales.x[activeScale])(e.layerX),\n              y: yScaleInverse(e.layerY),\n              scale: activeScale\n            }; //scale TODO\n\n            newOrder[2] = 1;\n          } else {\n            //set 1st selection\n            newOrder[0] = {\n              x: xInverse(scales.x[activeScale])(e.layerX),\n              y: yScaleInverse(e.layerY),\n              scale: activeScale\n            };\n            newOrder[2] = 0;\n          }\n\n          setSyntacticOrder(newOrder);\n        } //else if (toggle===\"foreshadowing\") {\n        //   if (!target.target) { //if target is an endpoint, indeterminate end\n        //\n        //\n        //   } else { //otherwise, change mouse to no symbol\n        //\n        //   }\n        //   //option to adjust gradient eventually\n        // } else\n        else if (toggle === \"certainty\" || toggle === \"importance\") {\n            setInflectTarget(target);\n          } else {\n            setInfo(null); //clear InfoBox\n\n            setInfo({\n              position: [e.x, e.y],\n              target: target,\n              type: \"interval\"\n            }); //displays interval properties when clicked\n          }\n\n        e.stopPropagation();\n      }); //---draw instants---//\n\n      svg.selectAll(\".instant\") // .data(activeData.filter(d => !d.foreshadowing && !d.cancelled))\n      .data(activeData).join(\"circle\").raise().attr(\"class\", \"instant pointer\").attr(\"r\", ([k, v]) => v.radius ? v.radius : radius) //TODO: custom radius accessibility\n      .attr(\"fill\", ([k, v]) => v.color ? v.color : \"black\") //if it has a color other than black, use that\n      .attr(\"opacity\", ([k, v]) => v.opacity ? v.opacity : 1) // .attr(\"cx\", d => generateScales(scales[d.scale]).x(logic ? logicScale(d.x) : d.x))\n      .attr(\"cx\", ([k, v]) => xScales[v.scale[0]].scale(v.x)) //scale x coordinate based on xScale defined in instant's scale property\n      .attr(\"cy\", ([k, v]) => yScale(v.y)).call(dragged).on(\"click\", (e, target) => {\n        switch (toggle) {\n          case \"cancelled\":\n            const newInstants = [...data];\n            const instant = newInstants.find(n => n.id === target.id);\n            instant.cancelled = true;\n            setData(newInstants);\n            break;\n\n          case \"connection\":\n            const newOrder = [...syntacticOrder];\n\n            if (newOrder[2] === 0) {\n              //set 2nd selection\n              newOrder[1] = target;\n              newOrder[2] = 1;\n            } else {\n              //set 1st selection\n              newOrder[0] = target;\n              newOrder[2] = 0;\n            }\n\n            setSyntacticOrder(newOrder);\n            break;\n\n          case \"foreshadowing\":\n            if (!target.target) {\n              //if target is an endpoint, indeterminate end\n              const newInstants = [...data];\n              const instant = newInstants.find(n => n.id === target.id);\n              instant.foreshadowing = true;\n              setData(newInstants);\n            } else {\n              //otherwise, change mouse to no symbol\n              console.log(\"forbidden\");\n            }\n\n            break;\n\n          case \"certainty\":\n            setInflectTarget(target);\n            break;\n\n          case \"importance\":\n            setInflectTarget(target);\n            break;\n\n          default:\n            setInfo(null); //clear InfoBox\n\n            setInfo({\n              position: [e.x, e.y],\n              target: target\n            });\n          //displays instant properties when clicked\n        } // if (toggle===\"cancelled\") {\n        //   const newInstants = [...data];\n        //   const instant = newInstants.find(n => n.id === target.id);\n        //   instant.cancelled = true;\n        //   setData(newInstants);\n        // } else if (){\n        //\n        // } else if (toggle===\"connection\") {\n        //   const newOrder = [...syntacticOrder];\n        //   if (newOrder[2]===0) { //set 2nd selection\n        //     newOrder[1] = target;\n        //     newOrder[2] = 1;\n        //   } else { //set 1st selection\n        //     newOrder[0] = target;\n        //     newOrder[2] = 0;\n        //   }\n        //   setSyntacticOrder(newOrder);\n        // } else if (toggle===\"foreshadowing\") { //todo: adjust gradient\n        //   if (!target.target) { //if target is an endpoint, indeterminate end\n        //     const newInstants = [...data];\n        //     const instant = newInstants.find(n => n.id === target.id);\n        //     instant.foreshadowing = true;\n        //     setData(newInstants);\n        //   } else { //otherwise, change mouse to no symbol\n        //     console.log(\"forbidden\");\n        //   }\n        // } else if (toggle===\"certainty\" || toggle===\"importance\"){\n        //   setInflectTarget(target);\n        // } else {\n        //   setInfo({position: [e.x, e.y], target: target}); //displays instant properties when clicked\n        // }\n\n\n        e.stopPropagation(); //stops deselect when bg is clicked\n      });\n      /*//---draw inflections---//\n       //--draw connetion inflection--//\n      //circle around instant\n      svg\n        .selectAll(\".connections\")\n        .data(activeData.filter(d => d.connections))\n        .join(\"circle\")\n        .raise()\n        .attr(\"class\", \"connections pointer\")\n        .attr(\"r\", n => n.radius? n.radius*1.5 : radius*2) //TODO: custom radius accessibility\n        .attr(\"fill\", \"none\")\n        .attr(\"stroke\", \"black\")\n        .attr(\"stroke-dasharray\", \"3\")\n        // .attr(\"opacity\", d => d.opacity ? d.opacity : 1)\n        .attr(\"cx\", d => xScales[d.scale].scale(d.x)) //scale x coordinate based on xScale defined in instant's scale property\n        .attr(\"cy\", d => yScale(d.y));\n       //link connecting circles\n      const ctLinker = linkHorizontal()\n        .source(instant => data.find(x => x.id === instant.id))\n        .target(instant => typeof(instant.connections[0])===\"object\" ? instant.connections[0] : data.find(x => x.id === instant.connections[0]))\n        // .target(() => {\n        //   //layerX, layerY\n        //   const y = yScaleInverse(499);\n        //   const x = xScales.find(n => n.text === \"biggie\").scaleInverse(778)\n        //   return {x: x, y: y}\n        // })\n        // .target(instant => data.find(x => x.id === instant.connections[0]))\n        .x(d => d.scale ? xScales[d.scale].scale(d.x) : d.x)\n        .y(d => d.scale ? yScale(d.y) : d.y);\n      svg\n        .selectAll(\".connectionLinks\")\n        .data(activeData.filter(n => n.connections && !n.connections[1])) //link starts from 1st one\n        .join(\"path\")\n        .raise()\n        .attr(\"class\", \"connectionLinks pointer\")\n        .attr(\"d\", ctLinker)\n        .attr(\"fill\", \"none\")\n        .attr(\"stroke\", \"black\")\n        // .attr(\"stroke\", n => n.color? n.color : \"black\")\n        // .attr(\"stroke-opacity\", n => n.opacity ? n.opacity : 1)\n        .attr(\"stroke-dasharray\", \"3\")\n       //initialize custom symbols\n      const cancelledSymbol = {\n        draw: (context, size) => {\n          let s = Math.sqrt(size)/2;\n              context.moveTo(s,0);\n              context.lineTo(s*2,s);\n              context.lineTo(s,s*2);\n              context.lineTo(0,s);\n              context.lineTo(-s,s*2);\n              context.lineTo(-s*2,s);\n              context.lineTo(-s,0);\n              context.lineTo(-s*2,-s);\n              context.lineTo(-s,-s*2);\n              context.lineTo(0,-s);\n              context.lineTo(s,-s*2);\n              context.lineTo(s*2,-s);\n              context.closePath();\n        }\n      };\n      //foreshadowing symbol\n      const fsSymbol = {\n        draw: (context, size) => {\n          let s = size;\n              context.moveTo(0,0);\n              context.lineTo(s*2,s/2);\n              context.lineTo(s*2,-s/2);\n              context.closePath();\n        }\n      };\n      //foreshadowing gradient\n      var fsg = svg.append(\"defs\").append(\"linearGradient\")\n      .attr(\"id\", \"fsgradient\")//id of the gradient\n      .attr(\"x1\", \"0%\")\n      .attr(\"x2\", \"100%\") //since its a horizontal linear gradient\n      .attr(\"y1\", \"0%\")\n      .attr(\"y2\", \"0%\");\n       fsg.append(\"stop\")\n      .attr(\"offset\", \"0%\")\n      .style(\"stop-color\", \"black\")//start in black. TODO: different color foreshadowing\n      .style(\"stop-opacity\", 1);\n       fsg.append(\"stop\")\n      .attr(\"offset\", \"100%\")\n      .style(\"stop-color\", \"black\")//end in transparent\n      .style(\"stop-opacity\", 0);\n       //---draw symbols---//\n      //TODO: doesn't display if cancelled is true from the start\n      svg\n        .selectAll(\".cancelled\")\n        .data(activeData.filter(d => d.cancelled))\n        .join(\"path\")\n        .raise()\n        .attr(\"class\", \"cancelled pointer\")\n        .attr(\"d\", symbol(cancelledSymbol, radius*radius*5))\n        .attr(\"fill\", d => d.color ? d.color : \"black\") //if it has a color other than black, use that\n        .attr(\"transform\", d => `translate(${xScales[d.scale].scale(d.x)}, ${yScale(d.y)})`)\n        .on(\"click\", (e, target) => {\n          if (toggle===\"cancelled\") {\n            const newInstants = [...data];\n            const instant = newInstants.find(n => n.id === target.id);\n            delete instant.cancelled;\n            setData(newInstants);\n          } else {\n            setInfo({position: [e.x, e.y], target: target}); //displays instant properties when clicked\n          }\n          e.stopPropagation();\n        });\n       //---draw foreshadowing---//\n      svg\n        .selectAll(\".foreshadowing\")\n        .data(activeData.filter(d => d.foreshadowing))\n        .join(\"path\")\n        .raise()\n        .attr(\"class\", \"foreshadowing pointer\")\n        .attr(\"d\", symbol(fsSymbol, radius*radius*5))\n        .style(\"fill\", \"url(#fsgradient)\")\n        .attr(\"transform\", d => `translate(${xScales[d.scale].scale(d.x)}, ${yScale(d.y)})`)\n        .on(\"click\", (e, target) => {\n          if (toggle===\"foreshadowing\") {\n            const newInstants = [...data];\n            const instant = newInstants.find(n => n.id === target.id);\n            delete instant.foreshadowing;\n            setData(newInstants);\n          } else {\n            setInfo({position: [e.x, e.y], target: target}); //displays instant properties when clicked\n          }\n          e.stopPropagation();\n        });\n      */\n      //---draw labels---//\n      // svg\n      //   .selectAll(\".zoneLabel\")\n      //   .data(zones)\n      //   .join(\"text\")\n      //   .attr(\"class\", \"zoneLabel\")\n      //   .text(v => v.text)\n      //   .attr(\"x\", v => xScales[v.scale].scale(v.start))\n      //   .attr(\"y\", v => yScale(v.yStart?v.yStart:yMin+5))\n      //   .attr(\"text-anchor\", \"middle\");\n\n      svg.selectAll(\".label\").data(activeData).join(\"text\").attr(\"class\", \"label\").text(([k, v]) => showLabel ? v.text : v.id).attr(\"x\", ([k, v]) => xScales[v.scale[0]].scale(v.x)).attr(\"y\", ([k, v]) => yScale(v.y - (rangeY > breakpoint ? rangeY * .05 : breakpoint / 5))) //vertical offset. see scales\n      .attr(\"text-anchor\", \"middle\"); // .attr(\"font-size\", fontSize);\n\n      svg.selectAll(\".intervalLabel\").data(intervals).join(\"text\").attr(\"class\", \"intervalLabel\").text(v => v.text).attr(\"x\", v => (xScales[v.source[1].scale[0]].scale(v.source[1].x) + xScales[v.target[1].scale[0]].scale(v.target[1].x)) / 2) //average scaled x values\n      .attr(\"y\", v => yScale(Math.max(v.source[1].y, v.target[1].y) + (rangeY > breakpoint ? rangeY * .06 : breakpoint / 5))) //.6 below lowest y, otherwise 1/5 of breakpoint\n      .attr(\"text-anchor\", \"middle\");\n    } //---zoom---//\n\n\n    const zoomBehavior = zoom().scaleExtent([1, 5]) //can zoom 2x smaller and 5x bigger\n    .translateExtent([[-50, 0], [dimensions.width + 50, dimensions.height]]) //limits how far graph can pan\n    .on(\"zoom\", e => {\n      const zoomState = e.transform; //returns zoom transformations as an object\n\n      setCurrentZoomState(zoomState);\n    }); //regular clicking\n\n    svg.on(\"click\", e => {\n      if (toggle === \"addInstant\") {\n        /*\n        if range of zoom > 10, Math.round(x)\n        if range of zoom <= 10 (floor: 10^0, ceiling: 10^1), use tenths (/10 -> /10^1)\n        if range of zoom <= 1 (floor: 10^-1, ceiling: 10^0), use hudredths (/100 -> (10^2))\n        if range of zoom <= .1 (floor: 10^-2, ceiling: 10^-1), use thousandths (/1000 -> (10^-3), etc.\n        const decimal = scales[activeScale]\n        xScales[key].scale\n        const decimal = scales[activeScale]\n        */\n        //TODO: zoom range matches up with current zoom\n        const zoomRange = xScales[activeScale].scale.domain()[1] - xScales[activeScale].scale.domain()[0]; //max-min\n        // const precision = Math.log10(zoomRange)<1 ? -(Math.floor(Math.log10(zoomRange)-1)) : 0;\n\n        const x = xScales[activeScale].scaleInverse(e.layerX);\n        const y = yScaleInverse(e.layerY); // console.log(Math.round(x*Math.pow(10, precision))/ Math.pow(10, precision));\n\n        setInflectTarget({\n          x: round(x, zoomRange),\n          y: Math.round(y)\n        });\n        setToggle(\"NewInstantForm\");\n      }\n\n      setInfo(null);\n    });\n    svg.call(zoomBehavior);\n  }, [data, setData, zones, scales, toggle, activeLayer, activeData, dimensions, logic, currentZoomState, setInfo, radius, showLabel, syntacticOrder]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: wrapperRef,\n    className: \"svgWrapper\",\n    children: /*#__PURE__*/_jsxDEV(\"svg\", {\n      id: \"graphic\",\n      ref: svgRef\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 751,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 750,\n    columnNumber: 5\n  }, this);\n}\n\n_s(Graphic, \"b4CAhwLk9FZLxktZNVY3UOkz6Nw=\", false, function () {\n  return [useResizeObserver];\n});\n\n_c = Graphic;\n;\nexport default Graphic;\n\nvar _c;\n\n$RefreshReg$(_c, \"Graphic\");","map":{"version":3,"sources":["/Users/skye/Desktop/Portfolio/2021/chronologies/client/src/components/Graphic.js"],"names":["React","useState","useEffect","useRef","select","scaleLinear","scaleOrdinal","axisBottom","axisLeft","linkHorizontal","format","drag","zoom","min","max","symbol","symbols","useResizeObserver","generateIntervals","Graphic","data","setData","activeLayer","zones","setZones","radius","info","setInfo","setInflectTarget","showLabel","toggle","setToggle","scales","setScales","syntacticOrder","setSyntacticOrder","activeScale","activeData","Object","entries","activeZones","logic","length","isNaN","x","svgRef","wrapperRef","dimensions","currentZoomState","setCurrentZoomState","yScales","y","forEach","k","v","scale","domain","height","range","inverse","intervals","svg","current","selectAll","remove","round","value","precision","Math","log10","floor","pow","logicScale","unknown","breakpoint","xMin","map","key","xMax","yMin","keys","yMax","rangeX","rangeY","xInverse","currentScale","width","xDrag","xScales","fromEntries","thisScale","hasSegments","segments","hideLabel","yPos","label","tickValues","scaleInverse","xSegments","i","n","push","proportion","segment","newXScale","rescaleX","newMin","newMax","yScale","yScaleInverse","yScaleInverseDrag","join","attr","start","yStart","end","yEnd","opacity","color","importance","on","e","target","position","type","stopPropagation","ticks","tickSize","append","style","call","raise","g","d","xAxis","tickFormat","hideLabels","text","yAxis","dragged","dx","subject","dy","newInstants","intervaler","source","interval","dashed","newOrder","layerX","layerY","instant","find","id","cancelled","foreshadowing","console","log","zoomBehavior","scaleExtent","translateExtent","zoomState","transform","zoomRange"],"mappings":"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A,MAAZ,EAAoB;AAAE;AACpB,oBAAMqB,WAAW,GAAG,CAAC,GAAG3H,IAAJ,CAApB;AACA,oBAAMmI,OAAO,GAAGR,WAAW,CAACS,IAAZ,CAAiBpD,CAAC,IAAIA,CAAC,CAACqD,EAAF,KAAS/B,MAAM,CAAC+B,EAAtC,CAAhB;AACAF,cAAAA,OAAO,CAACI,aAAR,GAAwB,IAAxB;AACAtI,cAAAA,OAAO,CAAC0H,WAAD,CAAP;AACD,aALD,MAKO;AAAE;AACPa,cAAAA,OAAO,CAACC,GAAR,CAAY,WAAZ;AACD;;AACD;;AACF,eAAK,WAAL;AACEjI,YAAAA,gBAAgB,CAAC8F,MAAD,CAAhB;AACA;;AACF,eAAK,YAAL;AACE9F,YAAAA,gBAAgB,CAAC8F,MAAD,CAAhB;AACA;;AACF;AACE/F,YAAAA,OAAO,CAAC,IAAD,CAAP,CADF,CACiB;;AACfA,YAAAA,OAAO,CAAC;AAACgG,cAAAA,QAAQ,EAAE,CAACF,CAAC,CAAC7E,CAAH,EAAM6E,CAAC,CAACtE,CAAR,CAAX;AAAuBuE,cAAAA,MAAM,EAAEA;AAA/B,aAAD,CAAP;AAAiD;AApCrD,SAD0B,CAuC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAD,QAAAA,CAAC,CAACI,eAAF,GAtE0B,CAsEL;AACtB,OArFH;AAuFA;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;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","sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\nimport { select, scaleLinear, scaleOrdinal, axisBottom, axisLeft, linkHorizontal, format, drag, zoom, min, max, symbol, symbols } from \"d3\";\nimport useResizeObserver from \"./useResizeObserver\";\nimport generateIntervals from \"./generateIntervals\";\n\nfunction Graphic({\n  data, setData,\n  activeLayer,\n  zones, setZones,\n  radius,\n  info, setInfo,\n  setInflectTarget,\n  showLabel,\n  toggle, setToggle,\n  scales, setScales,\n  syntacticOrder, setSyntacticOrder,\n  activeScale\n}) {\n\n  //all data is passed down from and synced to App.js\n  const activeData = Object.entries(data); //convert json to array for faster processing\n  const activeZones = Object.entries(zones);\n  //TODO: layers\n  // const activeData = activeLayer ? Object.entries(data).filter(([k,v]) => v.layer === activeLayer) : arrayData;\n\n  //convert scale object to array for faster processing\n\n\n  //is logical operators active?\n  const logic = data.length? isNaN(data[0].x): null; //TODO: refine logical operators\n\n  //initialize reference object to pass to svg in React Dom\n  const svgRef = useRef();\n  //svg wrapped in div bc otherwise resize observer callback won't work\n  const wrapperRef = useRef();\n  const dimensions = useResizeObserver(wrapperRef);\n  const [currentZoomState, setCurrentZoomState] = useState();\n\n  //hash map of y scales\n  const yScales = {};\n\n  //init scales\n  useEffect(() => {\n    if (!dimensions) return;\n    Object.entries(scales.y).forEach(([k, v]) => {\n      yScales[k]= {\n        scale: scaleLinear()\n        .domain([0, dimensions.height])\n        .range([v.min, v.max]),\n        inverse: scaleLinear()\n        .domain([v.min, v.max])\n        .range([0, dimensions.height]),\n        drag: scaleLinear()\n        .domain([-dimensions.height, dimensions.height])\n        .range([-(v.max-v.min), (v.max-v.min)]),\n      }\n    });\n  }, [dimensions, scales, currentZoomState]);\n\n  //initialize intervals between instants\n  const intervals = generateIntervals(data); //TODO: write updateIntervals function\n\n  //initialize variables\n  /*\n  var xMin = min(Object.entries(data).map(([key, {x}]) => logic ? logicScale(x) : x));\n  var xMax = max(Object.entries(data).map(([key, {x}]) => logic ? logicScale(x) : x));\n  var yMin = min(Object.entries(data).map(([key, {y}]) => y));\n  var yMax = max(Object.entries(data).map(([key, {y}]) => y));\n  */\n\n  //all d3 shennanigans goes in this hook. called initially and on every data change\n  useEffect(() => {\n    const svg = select(svgRef.current); //\"svg\" is the current version of svgRef data\n    //prevents crashing when useResizeObserver returns null before svg is rendered\n    if (!dimensions) return;\n    //removes svgs added using append()\n    svg\n      .selectAll(\".remove\")\n      .remove();\n\n    //rounding for data inputted thru paintbox interface\n    function round(value, range) {\n      const precision = Math.log10(range)<1 ? -(Math.floor(Math.log10(range)-1)) : 0;\n      return Math.round(value*Math.pow(10, precision))/ Math.pow(10, precision)\n    }\n\n\n    //---scales---//\n\n    //if time matches logical operator keyword, translate into index values, then map\n    const logicScale = scaleOrdinal([\"before\", \"now\", \"after\"], [-1, 0, 1]).unknown(0);\n\n    const breakpoint = 5;\n\n\n    const xMin = min(Object.entries(data).map(([key, {x}]) => logic ? logicScale(x) : x));\n    const xMax = max(Object.entries(data).map(([key, {x}]) => logic ? logicScale(x) : x));\n    // const yMin = min(Object.entries(data).map(([key, {y}]) => y));\n    // const yMax = max(Object.entries(data).map(([key, {y}]) => y));\n    const yMin=scales.y[Object.keys(scales.y)[0]].min; //TODO: right now it onselects first y scale\n    const yMax = scales.y[Object.keys(scales.y)[0]].max;\n    const rangeX = xMax-xMin; //0 is minX, 1 is maxX (reference findMinMax)\n    const rangeY = yMax-yMin;\n\n\n    /*\n    - Allow users to specify scale. x&y min max and units label\n    - for each scale, generateScale()\n    */\n\n    // function generateScales(currentScale) { //TODO: turn into dedicated scaleDrag\n    //\n    //   const xInverse = scaleLinear()\n    //     .domain([0, dimensions.width])\n    //     .range([currentScale.min, currentScale.max]) //maxRangeX-minRangeX gives section of x values displayed onscreen\n    //   const xDrag = scaleLinear()\n    //     .domain([-dimensions.width, dimensions.width])\n    //     .range([-(currentScale.domain()[1]-currentScale.domain()[0]), (currentScale.domain()[1]-currentScale.domain()[0])]) //maxRangeX-minRangeX gives section of x values displayed onscreen\n    //   const yInverse = scaleLinear()\n    //     .domain([-dimensions.height, dimensions.height])\n    //     .range((rangeY>breakpoint) ? [-rangeY, rangeY] : [-breakpoint*5, breakpoint*5])\n    //\n    //\n    //   return {\n    //     xInverse, xDrag, yInverse\n    //   };\n    // }\n    const xInverse = (currentScale) => scaleLinear()\n      .domain([0, dimensions.width])\n      .range([currentScale.min, currentScale.max]) //maxRangeX-minRangeX gives section of x values displayed onscreen\n    const xDrag = (currentScale) => scaleLinear()\n      .domain([-dimensions.width, dimensions.width])\n      .range([-(currentScale.domain()[1]-currentScale.domain()[0]), (currentScale.domain()[1]-currentScale.domain()[0])]) //maxRangeX-minRangeX gives section of x values displayed onscreen\n    // const yInverse = scaleLinear()\n    //   .domain([-dimensions.height, dimensions.height])\n    //   .range((rangeY>breakpoint) ? [-rangeY, rangeY] : [-breakpoint*5, breakpoint*5])\n\n\n    //scales values to screen pixels\n    /*\n    {\n      biggie: {\n        ...\n        scale: generateScale()\n      }\n      ...\n    }\n    */\n\n    /*\n    xScale =\n    {\n\n  }\n    */\n\n    // const xScales1 = Object.entries(scales).map(([key, thisScale]) => [\n    //     key,\n    //     {\n    //       scale: scaleLinear() //scaleLinear takes domain (data values) & maps onto range (screen pixel values)\n    //         .domain([thisScale.min, thisScale.max])\n    //         .range([0, dimensions.width]),\n    //       hasSegments: thisScale.segments.length?true:false,\n    //       yPos: thisScale.yPos,\n    //       label: thisScale.label,\n    //       tickValues: thisScale.tickValues?thisScale.tickValues:null\n    //     }\n    //   ]);\n    //   console.log(xScales1)\n\n    //TODO: fromEntries & entries not compatible with some older browsers\n    const xScales = Object.fromEntries( //for every scale in scales data, generate an xScale\n      Object.entries(scales.x).map(([key, thisScale]) => [\n        key,\n        {\n          scale: scaleLinear() //scaleLinear takes domain (data values) & maps onto range (screen pixel values)\n            .domain([thisScale.min, thisScale.max])\n            .range([0, dimensions.width]),\n          hasSegments: thisScale.segments.length?true:false,\n          hideLabel: thisScale.hideLabel,\n          yPos: thisScale.yPos,\n          label: `${key} (${thisScale.label})`,\n          tickValues: thisScale.tickValues?thisScale.tickValues:null,\n          scaleInverse: scaleLinear() //for NewInstantForm\n            .domain([0, dimensions.width])\n            .range([thisScale.min, thisScale.max])\n        }\n      ])\n    );\n\n\n    const xSegments = () => {\n      const segments = [];\n      Object.keys(scales.x).forEach((key, i) => {\n        const thisScale = scales.x[key];\n        // const segments = [];\n        if (!thisScale.segments.length) {\n          return;\n        }\n        thisScale.segments.map(n => {\n          const min = n.min?n.min:thisScale.min; //if segment contains a min, set that as min. otherwise, set scale min as min.\n          const max = n.max?n.max:thisScale.max;\n          // console.log(xScales[i].scale(min));\n          segments.push({\n            scale: key,\n            yPos: thisScale.yPos,\n            proportion: (max-min)/(thisScale.max-thisScale.min),\n            segment: scaleLinear()\n            .domain([min, max])\n            .range([xScales[key].scale(min), xScales[key].scale(max)])\n          })\n        })\n      });\n      return segments;\n    }\n\n\n    /*\n      xScales(generateScales(scaleLinear(scale)))\n      - take xScale and rescale according to transformations (newXScale)\n      - update each array entry's domain with that of newXScale\n    */\n    //if there is a zoom transform, override each xScales.scale with adjusted scale\n    if (currentZoomState) {\n      Object.entries(xScales).forEach(([key,thisScale]) => {\n        const newXScale = currentZoomState.rescaleX(thisScale.scale); //zoom state comes w methods for transformations\n        const newMin = newXScale.domain()[0]\n        const newMax = newXScale.domain()[1];\n\n        //applies zoom transformations to scale + scaleInverse\n        xScales[key].scale = newXScale;\n      });\n\n\n    };\n    // const xScale = scaleLinear()\n    //   .domain([xMin, xMax]) //scaleLinear takes domain (data values) & maps onto range (screen pixel values)\n    //   .range([0, dimensions.width]);\n    const yScale = scaleLinear()\n      //if difference in y vaules greater than 5, resize to min and max\n      // .domain((rangeY>breakpoint) ? [yMin, yMax] : [yMin-breakpoint, yMax+breakpoint])\n      .domain([yMin, yMax])\n      .range([0, dimensions.height]);\n    //inverse scales for drag behavior\n    // const xScaleInverse = scaleLinear()\n    //   .domain([-dimensions.width, dimensions.width])\n    //   .range([-rangeX, rangeX]); //maxRangeX-minRangeX gives section of x values displayed onscreen\n    const yScaleInverse = scaleLinear()\n      .domain([0, dimensions.height])\n      .range([yMin, yMax])\n      // .range((rangeY>breakpoint) ? [yMin, yMax] : [yMin-breakpoint, yMax+breakpoint]);\n    const yScaleInverseDrag = scaleLinear()\n      .domain([-dimensions.height, dimensions.height])\n      .range([-rangeY, rangeY])\n      // .range((rangeY>breakpoint) ? [-rangeY, rangeY] : [-breakpoint*5, breakpoint*5]);\n\n\n\n\n\n    //---draw zones---//\n    if (activeZones.length) {\n      svg\n      .selectAll(\".zones\")\n      .data(activeZones)\n      .join(\"rect\")\n      .attr(\"class\", \"zones\")\n      .attr(\"x\", ([k, v]) => xScales[v.scale[0]].scale(v.start))\n      // .attr(\"x\", n => generateScales(scales[n.scale]).x(n.start))\n      // .attr(\"y\", n => n.yStart ? yScale(n.yStart) : yScale(minMax[2]))\n      .attr(\"y\", ([k, v]) => v.yStart ? yScale(v.yStart) : yMin-10) //TODO: if no yStart, minimum y value\n      .attr(\"width\", ([k, v]) => xScales[v.scale[0]].scale(v.end) - xScales[v.scale[0]].scale(v.start))\n      .attr(\"height\", ([k, v]) => {\n        if (v.yStart & v.yEnd) {\n          return (yScale(v.yEnd)-yScale(v.yStart))\n        } else if (v.yStart) {\n          return (yScale(yMax+10)-yScale(v.yStart))\n        } else {\n          return (yScale(yMax+10)) //TODO: if no yStart, minimum y value\n          // return (yScale(minMax[3])-yScale(minMax[2]))\n        }})\n      .attr(\"opacity\", ([k, v]) => v.opacity ? v.opacity : 0.5)\n      .attr(\"fill\", ([k, v]) => v.color ? v.color : \"#999\")\n      .attr(\"stroke\", \"black\") //TODO: stroke be different colors\n      .attr(\"stroke-width\", ([k, v]) => v.importance ? v.importance*2 : 0)\n      .on(\"click\", (e, target) => {\n        if (toggle===\"certainty\" || toggle===\"importance\") { //pulls up inflection menu\n          setInflectTarget(target);\n        } else { //displays zone properties when clicked\n          setInfo(null); //clear InfoBox\n          setInfo({position: [e.x, e.y], target: target, type: \"zone\"});  //TODO: set info to null when clicking same zone again\n        }\n        e.stopPropagation();\n      });\n    }\n\n    //---draw bottom axis---//\n\n    xSegments().forEach(n => {\n      const segment = axisBottom(n.segment)\n      // .ticks(n.proportion<.33?5:null, \"f\");\n      .ticks(null, \"f\")\n      .tickSize(-dimensions.height);\n\n      svg\n        .append(\"g\")\n        .attr(\"class\", \"remove\")\n        .style(\"transform\", `translateY(${dimensions.height*n.yPos}px)`)\n        .call(segment)\n        .raise()\n        .call(g => g.select(\".domain\") //removes solid black axis bar\n          .remove())\n        .call(g => g.selectAll(\".tick line\") //styles individual ticks\n          .attr(\"stroke-opacity\", 0.25))\n        .call(g => g.selectAll(\".tick text\")\n          .attr(\"y\", 10)\n          .attr(\"opacity\", (d, i) => { //TODO: remove instead of setting opacity to 0\n            if ((n.proportion<.25)&&(i%3)) { //less than 1/4, label every 3 ticks\n              return 0;\n            } else if ((n.proportion<.33)&&(i%2)) { //less than 1/3, label every other tick\n              return 0;\n            } else {\n              return 0.5\n            }\n          })\n        );\n    });\n\n    Object.entries(xScales).forEach(([key,thisScale]) => {\n      const xAxis = axisBottom(thisScale.scale).tickValues(thisScale.tickValues)\n      .tickFormat(format(''))\n      .tickSize(-dimensions.height);\n\n      if (!thisScale.hasSegments || thisScale.tickValues ) {\n        svg\n          .append(\"g\")\n          .attr(\"class\", \"remove\")\n          .style(\"transform\", `translateY(${dimensions.height*thisScale.yPos}px)`)\n          .call(xAxis)\n          .raise()\n          .call(g => g.select(\".domain\") //removes solid black axis bar\n            .remove())\n          .call(g => g.selectAll(\".tick line\") //styles individual ticks\n            .attr(\"stroke-opacity\", 0.25))\n          .call(g => g.selectAll(\".tick text\")\n            .attr(\"y\", 10) //TODO: dynamic tick text spacing for accessibility\n            .attr(\"opacity\", 0.5));\n      }\n      if (!thisScale.hideLabels) {\n        svg\n          .append(\"text\")\n          .text(thisScale.label)\n          .attr(\"class\", \"axisLabel smallTxt remove\")\n          .attr(\"x\", dimensions.width/2)\n          .attr(\"y\", dimensions.height*(thisScale.yPos+.07))\n          .attr(\"text-anchor\", \"middle\")\n          .attr(\"opacity\", 0.5);\n        }\n      }\n\n    );\n\n    //--draw vertical axis--//\n\n    const yAxis = axisLeft(yScale).tickValues(scales.y[Object.keys(scales.y)[0]].min, scales.y[Object.keys(scales.y)[0]].max);\n\n    svg\n      .append(\"g\")\n      .attr(\"class\", \"remove\")\n      // .style(\"transform\", `translateY(${dimensions.height*thisScale.yPos}px)`)\n      .call(yAxis)\n      .raise()\n      .call(g => g.select(\".domain\") //removes solid black axis bar\n        .remove())\n      .call(g => g.selectAll(\".tick line\") //styles individual ticks\n        .attr(\"stroke-opacity\", 0.5))\n      .call(g => g.selectAll(\".tick text\")\n        .attr(\"y\", 10) //TODO: dynamic tick text spacing for accessibility\n        .attr(\"opacity\", 0.5));\n\n    //--drag behavior--//\n    const dragged = drag()\n      // .on(\"start\", e => {\n      //   select(this).attr(\"stroke\", \"black\");\n      // })\n      .on(\"drag\", e => {\n        //TODO: extract precision function to round new pos\n        const dx = xDrag(xScales[e.subject[1].scale[0]].scale)(e.dx);\n        // const dx = xScales.scaleInverse\n        const dy = yScaleInverseDrag(e.dy);\n        const newInstants = {...data}; //always make a copy when updating array\n\n        //find array element in data with matching ID and set new x y coordinates\n        newInstants[e.subject[0]].x += dx;\n        newInstants[e.subject[0]].y += dy;\n\n        setData(newInstants);\n      });\n\n    if (Object.entries(data).length) {\n      //---draw intervals---//\n      const intervaler = linkHorizontal()\n        .source(interval => interval.source[1])\n        .target(interval => interval.target[1])\n        // .x(n => generateScales(scales[n.scale]).x(logic ? logicScale(n.x) : n.x))\n        .x(d => xScales[d.scale[0]].scale(d.x))\n        .y(d => yScale(d.y));\n\n      svg\n        .selectAll(\".interval\")\n        .data(intervals)\n        .join(\"path\")\n        .raise()\n        .attr(\"class\", \"interval pointer\")\n        .attr(\"d\", intervaler)\n        .attr(\"fill\", \"none\")\n        .attr(\"stroke\", n => n.color? n.color : \"black\")\n        .attr(\"stroke-width\", n => n.width ? n.width : radius/2)\n        .attr(\"stroke-opacity\", n => n.opacity ? n.opacity : 1)\n        .attr(\"stroke-dasharray\", n => n.dashed ? n.dashed : null)\n        .on(\"click\", (e, target) => {\n          if (toggle===\"connection\") {\n            const newOrder = [...syntacticOrder];\n            if (newOrder[2]===0) { //set 2nd selection\n              newOrder[1] = {x:xInverse(scales.x[activeScale])(e.layerX), y:yScaleInverse(e.layerY), scale:activeScale}; //scale TODO\n              newOrder[2] = 1;\n            } else { //set 1st selection\n              newOrder[0] = {x:xInverse(scales.x[activeScale])(e.layerX), y:yScaleInverse(e.layerY), scale:activeScale};\n              newOrder[2] = 0;\n            }\n            setSyntacticOrder(newOrder);\n          }\n          //else if (toggle===\"foreshadowing\") {\n          //   if (!target.target) { //if target is an endpoint, indeterminate end\n          //\n          //\n          //   } else { //otherwise, change mouse to no symbol\n          //\n          //   }\n          //   //option to adjust gradient eventually\n          // } else\n          else if (toggle===\"certainty\" || toggle===\"importance\") {\n            setInflectTarget(target);\n          } else {\n            setInfo(null); //clear InfoBox\n            setInfo({position: [e.x, e.y], target: target, type: \"interval\"}); //displays interval properties when clicked\n          }\n          e.stopPropagation();\n        });\n\n\n\n      //---draw instants---//\n      svg\n        .selectAll(\".instant\")\n        // .data(activeData.filter(d => !d.foreshadowing && !d.cancelled))\n        .data(activeData)\n        .join(\"circle\")\n        .raise()\n        .attr(\"class\", \"instant pointer\")\n        .attr(\"r\", ([k,v]) => v.radius? v.radius : radius) //TODO: custom radius accessibility\n        .attr(\"fill\", ([k,v]) => v.color ? v.color : \"black\") //if it has a color other than black, use that\n        .attr(\"opacity\", ([k,v]) => v.opacity ? v.opacity : 1)\n        // .attr(\"cx\", d => generateScales(scales[d.scale]).x(logic ? logicScale(d.x) : d.x))\n        .attr(\"cx\", ([k,v]) => xScales[v.scale[0]].scale(v.x)) //scale x coordinate based on xScale defined in instant's scale property\n        .attr(\"cy\", ([k,v]) => yScale(v.y))\n        .call(dragged)\n        .on(\"click\", (e, target) => {\n          switch (toggle) {\n            case \"cancelled\":\n              const newInstants = [...data];\n              const instant = newInstants.find(n => n.id === target.id);\n              instant.cancelled = true;\n              setData(newInstants);\n              break;\n            case \"connection\":\n              const newOrder = [...syntacticOrder];\n              if (newOrder[2]===0) { //set 2nd selection\n                newOrder[1] = target;\n                newOrder[2] = 1;\n              } else { //set 1st selection\n                newOrder[0] = target;\n                newOrder[2] = 0;\n              }\n              setSyntacticOrder(newOrder);\n              break;\n            case \"foreshadowing\":\n              if (!target.target) { //if target is an endpoint, indeterminate end\n                const newInstants = [...data];\n                const instant = newInstants.find(n => n.id === target.id);\n                instant.foreshadowing = true;\n                setData(newInstants);\n              } else { //otherwise, change mouse to no symbol\n                console.log(\"forbidden\");\n              }\n              break;\n            case \"certainty\":\n              setInflectTarget(target);\n              break;\n            case \"importance\":\n              setInflectTarget(target);\n              break;\n            default:\n              setInfo(null); //clear InfoBox\n              setInfo({position: [e.x, e.y], target: target}); //displays instant properties when clicked\n          }\n          // if (toggle===\"cancelled\") {\n          //   const newInstants = [...data];\n          //   const instant = newInstants.find(n => n.id === target.id);\n          //   instant.cancelled = true;\n          //   setData(newInstants);\n          // } else if (){\n          //\n          // } else if (toggle===\"connection\") {\n          //   const newOrder = [...syntacticOrder];\n          //   if (newOrder[2]===0) { //set 2nd selection\n          //     newOrder[1] = target;\n          //     newOrder[2] = 1;\n          //   } else { //set 1st selection\n          //     newOrder[0] = target;\n          //     newOrder[2] = 0;\n          //   }\n          //   setSyntacticOrder(newOrder);\n          // } else if (toggle===\"foreshadowing\") { //todo: adjust gradient\n          //   if (!target.target) { //if target is an endpoint, indeterminate end\n          //     const newInstants = [...data];\n          //     const instant = newInstants.find(n => n.id === target.id);\n          //     instant.foreshadowing = true;\n          //     setData(newInstants);\n          //   } else { //otherwise, change mouse to no symbol\n          //     console.log(\"forbidden\");\n          //   }\n          // } else if (toggle===\"certainty\" || toggle===\"importance\"){\n          //   setInflectTarget(target);\n          // } else {\n          //   setInfo({position: [e.x, e.y], target: target}); //displays instant properties when clicked\n          // }\n          e.stopPropagation(); //stops deselect when bg is clicked\n        });\n\n      /*//---draw inflections---//\n\n      //--draw connetion inflection--//\n      //circle around instant\n      svg\n        .selectAll(\".connections\")\n        .data(activeData.filter(d => d.connections))\n        .join(\"circle\")\n        .raise()\n        .attr(\"class\", \"connections pointer\")\n        .attr(\"r\", n => n.radius? n.radius*1.5 : radius*2) //TODO: custom radius accessibility\n        .attr(\"fill\", \"none\")\n        .attr(\"stroke\", \"black\")\n        .attr(\"stroke-dasharray\", \"3\")\n        // .attr(\"opacity\", d => d.opacity ? d.opacity : 1)\n        .attr(\"cx\", d => xScales[d.scale].scale(d.x)) //scale x coordinate based on xScale defined in instant's scale property\n        .attr(\"cy\", d => yScale(d.y));\n\n      //link connecting circles\n      const ctLinker = linkHorizontal()\n        .source(instant => data.find(x => x.id === instant.id))\n        .target(instant => typeof(instant.connections[0])===\"object\" ? instant.connections[0] : data.find(x => x.id === instant.connections[0]))\n        // .target(() => {\n        //   //layerX, layerY\n        //   const y = yScaleInverse(499);\n        //   const x = xScales.find(n => n.text === \"biggie\").scaleInverse(778)\n        //   return {x: x, y: y}\n        // })\n        // .target(instant => data.find(x => x.id === instant.connections[0]))\n        .x(d => d.scale ? xScales[d.scale].scale(d.x) : d.x)\n        .y(d => d.scale ? yScale(d.y) : d.y);\n      svg\n        .selectAll(\".connectionLinks\")\n        .data(activeData.filter(n => n.connections && !n.connections[1])) //link starts from 1st one\n        .join(\"path\")\n        .raise()\n        .attr(\"class\", \"connectionLinks pointer\")\n        .attr(\"d\", ctLinker)\n        .attr(\"fill\", \"none\")\n        .attr(\"stroke\", \"black\")\n        // .attr(\"stroke\", n => n.color? n.color : \"black\")\n        // .attr(\"stroke-opacity\", n => n.opacity ? n.opacity : 1)\n        .attr(\"stroke-dasharray\", \"3\")\n\n      //initialize custom symbols\n      const cancelledSymbol = {\n        draw: (context, size) => {\n          let s = Math.sqrt(size)/2;\n              context.moveTo(s,0);\n              context.lineTo(s*2,s);\n              context.lineTo(s,s*2);\n              context.lineTo(0,s);\n              context.lineTo(-s,s*2);\n              context.lineTo(-s*2,s);\n              context.lineTo(-s,0);\n              context.lineTo(-s*2,-s);\n              context.lineTo(-s,-s*2);\n              context.lineTo(0,-s);\n              context.lineTo(s,-s*2);\n              context.lineTo(s*2,-s);\n              context.closePath();\n        }\n      };\n      //foreshadowing symbol\n      const fsSymbol = {\n        draw: (context, size) => {\n          let s = size;\n              context.moveTo(0,0);\n              context.lineTo(s*2,s/2);\n              context.lineTo(s*2,-s/2);\n              context.closePath();\n        }\n      };\n      //foreshadowing gradient\n      var fsg = svg.append(\"defs\").append(\"linearGradient\")\n      .attr(\"id\", \"fsgradient\")//id of the gradient\n      .attr(\"x1\", \"0%\")\n      .attr(\"x2\", \"100%\") //since its a horizontal linear gradient\n      .attr(\"y1\", \"0%\")\n      .attr(\"y2\", \"0%\");\n\n      fsg.append(\"stop\")\n      .attr(\"offset\", \"0%\")\n      .style(\"stop-color\", \"black\")//start in black. TODO: different color foreshadowing\n      .style(\"stop-opacity\", 1);\n\n      fsg.append(\"stop\")\n      .attr(\"offset\", \"100%\")\n      .style(\"stop-color\", \"black\")//end in transparent\n      .style(\"stop-opacity\", 0);\n\n      //---draw symbols---//\n      //TODO: doesn't display if cancelled is true from the start\n      svg\n        .selectAll(\".cancelled\")\n        .data(activeData.filter(d => d.cancelled))\n        .join(\"path\")\n        .raise()\n        .attr(\"class\", \"cancelled pointer\")\n        .attr(\"d\", symbol(cancelledSymbol, radius*radius*5))\n        .attr(\"fill\", d => d.color ? d.color : \"black\") //if it has a color other than black, use that\n        .attr(\"transform\", d => `translate(${xScales[d.scale].scale(d.x)}, ${yScale(d.y)})`)\n        .on(\"click\", (e, target) => {\n          if (toggle===\"cancelled\") {\n            const newInstants = [...data];\n            const instant = newInstants.find(n => n.id === target.id);\n            delete instant.cancelled;\n            setData(newInstants);\n          } else {\n            setInfo({position: [e.x, e.y], target: target}); //displays instant properties when clicked\n          }\n          e.stopPropagation();\n        });\n\n      //---draw foreshadowing---//\n      svg\n        .selectAll(\".foreshadowing\")\n        .data(activeData.filter(d => d.foreshadowing))\n        .join(\"path\")\n        .raise()\n        .attr(\"class\", \"foreshadowing pointer\")\n        .attr(\"d\", symbol(fsSymbol, radius*radius*5))\n        .style(\"fill\", \"url(#fsgradient)\")\n        .attr(\"transform\", d => `translate(${xScales[d.scale].scale(d.x)}, ${yScale(d.y)})`)\n        .on(\"click\", (e, target) => {\n          if (toggle===\"foreshadowing\") {\n            const newInstants = [...data];\n            const instant = newInstants.find(n => n.id === target.id);\n            delete instant.foreshadowing;\n            setData(newInstants);\n          } else {\n            setInfo({position: [e.x, e.y], target: target}); //displays instant properties when clicked\n          }\n          e.stopPropagation();\n        });\n*/\n      //---draw labels---//\n      // svg\n      //   .selectAll(\".zoneLabel\")\n      //   .data(zones)\n      //   .join(\"text\")\n      //   .attr(\"class\", \"zoneLabel\")\n      //   .text(v => v.text)\n      //   .attr(\"x\", v => xScales[v.scale].scale(v.start))\n      //   .attr(\"y\", v => yScale(v.yStart?v.yStart:yMin+5))\n      //   .attr(\"text-anchor\", \"middle\");\n\n      svg\n        .selectAll(\".label\")\n        .data(activeData)\n        .join(\"text\")\n        .attr(\"class\", \"label\")\n        .text(([k,v]) => showLabel ? v.text : v.id)\n        .attr(\"x\", ([k,v]) => xScales[v.scale[0]].scale(v.x))\n        .attr(\"y\", ([k,v]) => yScale(v.y - (rangeY>breakpoint ? rangeY*.05 : breakpoint/5))) //vertical offset. see scales\n        .attr(\"text-anchor\", \"middle\");\n        // .attr(\"font-size\", fontSize);\n\n      svg\n        .selectAll(\".intervalLabel\")\n        .data(intervals)\n        .join(\"text\")\n        .attr(\"class\", \"intervalLabel\")\n        .text(v => v.text)\n        .attr(\"x\", v => (xScales[v.source[1].scale[0]].scale(v.source[1].x)+xScales[v.target[1].scale[0]].scale(v.target[1].x))/2) //average scaled x values\n        .attr(\"y\", v => yScale(Math.max(v.source[1].y, v.target[1].y) + (rangeY>breakpoint ? rangeY*.06 : breakpoint/5))) //.6 below lowest y, otherwise 1/5 of breakpoint\n        .attr(\"text-anchor\", \"middle\");\n\n    }\n\n\n\n    //---zoom---//\n    const zoomBehavior = zoom()\n      .scaleExtent([1, 5]) //can zoom 2x smaller and 5x bigger\n      .translateExtent([[-50, 0], [dimensions.width+50, dimensions.height]]) //limits how far graph can pan\n      .on(\"zoom\", e => {\n        const zoomState = e.transform; //returns zoom transformations as an object\n        setCurrentZoomState(zoomState);\n      });\n\n    //regular clicking\n    svg.on(\"click\", (e) => {\n      if (toggle===\"addInstant\") {\n        /*\n        if range of zoom > 10, Math.round(x)\n        if range of zoom <= 10 (floor: 10^0, ceiling: 10^1), use tenths (/10 -> /10^1)\n        if range of zoom <= 1 (floor: 10^-1, ceiling: 10^0), use hudredths (/100 -> (10^2))\n        if range of zoom <= .1 (floor: 10^-2, ceiling: 10^-1), use thousandths (/1000 -> (10^-3), etc.\n        const decimal = scales[activeScale]\n        xScales[key].scale\n        const decimal = scales[activeScale]\n        */\n        //TODO: zoom range matches up with current zoom\n        const zoomRange = xScales[activeScale].scale.domain()[1] - xScales[activeScale].scale.domain()[0]; //max-min\n        // const precision = Math.log10(zoomRange)<1 ? -(Math.floor(Math.log10(zoomRange)-1)) : 0;\n        const x = xScales[activeScale].scaleInverse(e.layerX);\n        const y = yScaleInverse(e.layerY);\n        // console.log(Math.round(x*Math.pow(10, precision))/ Math.pow(10, precision));\n        setInflectTarget({x: round(x, zoomRange), y: Math.round(y)});\n        setToggle(\"NewInstantForm\");\n      }\n      setInfo(null);\n    });\n    svg.call(zoomBehavior);\n\n  }, [data, setData, zones, scales, toggle, activeLayer, activeData, dimensions, logic, currentZoomState, setInfo, radius, showLabel, syntacticOrder]);\n\n  return (\n    <div ref={wrapperRef} className=\"svgWrapper\">\n      <svg id=\"graphic\" ref={svgRef}>\n      </svg>\n    </div>\n  );\n};\n\n\nexport default Graphic;\n"]},"metadata":{},"sourceType":"module"}