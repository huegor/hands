{"ast":null,"code":"var _jsxFileName = \"/Users/skye/Desktop/Portfolio/2021/chronologies/client/src/components/Graphic.js\",\n    _s = $RefreshSig$();\n\nimport React, { useState, useEffect, useRef } from 'react';\nimport { select, scaleLinear, scaleOrdinal, axisBottom, linkHorizontal, format, drag, zoom, min, max, symbol, symbols } from \"d3\";\nimport useResizeObserver from \"./useResizeObserver\";\nimport generateLinks from \"./generateLinks\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nfunction Graphic({\n  data,\n  setData,\n  activeLayer,\n  zones,\n  setZones,\n  radius,\n  info,\n  setInfo,\n  setInflectTarget,\n  showLabel,\n  toggle,\n  setToggle,\n  scales,\n  setScales,\n  syntacticOrder,\n  setSyntacticOrder,\n  activeScale\n}) {\n  _s();\n\n  //all data is passed down from and synced to App.js\n  const activeData = activeLayer ? data.filter(d => d.layer === activeLayer) : data; //is logical operators active?\n\n  const logic = isNaN(data[0].x); //Todo\n  //initialize reference object to pass to svg in React Dom\n\n  const svgRef = useRef(); //svg wrapped in div bc otherwise resize observer callback won't work\n\n  const wrapperRef = useRef();\n  const dimensions = useResizeObserver(wrapperRef);\n  const [currentZoomState, setCurrentZoomState] = useState(); // //initialize links between instants\n\n  const links = generateLinks(activeData); //all d3 shennanigans goes in this hook. called initially and on every data change\n\n  useEffect(() => {\n    const svg = select(svgRef.current); //\"svg\" is the current version of svgRef data\n    //prevents crashing when useResizeObserver returns null before svg is rendered\n\n    if (!dimensions) return; //removes svgs added using append()\n\n    svg.selectAll(\".remove\").remove(); //initialize inflections for .selectAll\n    //add cancelled class\n    //---scales---//\n    //if time matches logical operator keyword, translate into index values, then map\n\n    const logicScale = scaleOrdinal([\"before\", \"now\", \"after\"], [-1, 0, 1]).unknown(0);\n    const breakpoint = 5;\n    const xMin = min(data.map(({\n      x\n    }) => logic ? logicScale(x) : x));\n    const xMax = max(data.map(({\n      x\n    }) => logic ? logicScale(x) : x));\n    const yMin = min(data.map(({\n      y\n    }) => y));\n    const yMax = max(data.map(({\n      y\n    }) => y));\n    const rangeX = xMax - xMin; //0 is minX, 1 is maxX (reference findMinMax)\n\n    const rangeY = yMax - yMin; //TODO: scaleTime()\n    //for multiple scales, generate a new scale for each x/y min - x/y max\n\n    /*\n    - Allow users to specify scale. x&y min max and units\n    - for each scale, generateScale()\n     */\n\n    function generateScales(currentScale) {\n      const x = scaleLinear().domain([currentScale.min, currentScale.max]) //scaleLinear takes domain (data values) & maps onto range (screen pixel values)\n      .range([0, dimensions.width]);\n      const y = scaleLinear() //if difference in y vaules greater than 5, resize to min and max\n      .domain(rangeY > breakpoint ? [yMin, yMax] : [yMin - breakpoint, yMax + breakpoint]).range([0, dimensions.height]);\n      const xInverse = scaleLinear().domain([0, dimensions.width]).range([currentScale.min, currentScale.max]); //maxRangeX-minRangeX gives section of x values displayed onscreen\n\n      const xInverseDrag = scaleLinear().domain([-dimensions.width, dimensions.width]).range([-(currentScale.max - currentScale.min), currentScale.max - currentScale.min]); //maxRangeX-minRangeX gives section of x values displayed onscreen\n\n      const yInverse = scaleLinear().domain([-dimensions.height, dimensions.height]).range(rangeY > breakpoint ? [-rangeY, rangeY] : [-breakpoint * 5, breakpoint * 5]);\n      return {\n        x,\n        y,\n        xInverse,\n        xInverseDrag,\n        yInverse\n      };\n    } //scales values to screen pixels\n\n    /*\n    {\n      biggie: {\n        ...\n        scale: generateScale()\n      }\n      ...\n    }\n    */\n    // const xScales = () => {\n    //   Object.keys(scales).forEach(key => { //for every scale in scales data, generate an xScale\n    //     // const thisScale = scales[key];\n    //     scales[key] = {...scales[key], scale:generateScales(scales[key]).x}\n    //   });\n    //   return scales;\n    // }\n\n\n    const xScales = Object.fromEntries(Object.entries(scales).map(([key, thisScale]) => [key, {\n      scale: scaleLinear() //scaleLinear takes domain (data values) & maps onto range (screen pixel values)\n      .domain([thisScale.min, thisScale.max]).range([0, dimensions.width]),\n      // segments: thisScale.segments.map(n => {\n      //   scaleLinear() //scaleLinear takes domain (data values) & maps onto range (screen pixel values)\n      //     .domain([thisScale.min, thisScale.max])\n      //     .range([0, dimensions.width])\n      // }),\n      yPos: thisScale.yPos,\n      units: thisScale.units,\n      scaleInverse: scaleLinear() //scaleLinear takes domain (data values) & maps onto range (screen pixel values)\n      .domain([-dimensions.width, dimensions.width]).range([-(thisScale.max - thisScale.min), thisScale.max - thisScale.min])\n    }])); // const xScales = Object.keys(scales).map(key => { //for every scale in scales data, generate an xScale\n    //   const thisScale = scales[key];\n    //   return ({\n    //     name: key,\n    //     scale: scaleLinear() //scaleLinear takes domain (data values) & maps onto range (screen pixel values)\n    //       .domain([thisScale.min, thisScale.max])\n    //       .range([0, dimensions.width]),\n    //     // segments: thisScale.segments.map(n => {\n    //     //   scaleLinear() //scaleLinear takes domain (data values) & maps onto range (screen pixel values)\n    //     //     .domain([thisScale.min, thisScale.max])\n    //     //     .range([0, dimensions.width])\n    //     // }),\n    //     yPos: thisScale.yPos,\n    //     units: thisScale.units,\n    //     scaleInverse: scaleLinear() //scaleLinear takes domain (data values) & maps onto range (screen pixel values)\n    //       .domain([-dimensions.width, dimensions.width])\n    //       .range([-(thisScale.max-thisScale.min), (thisScale.max-thisScale.min)])\n    //   })\n    // });\n    //\n    // const xSegments = Object.keys(scales).map((key, i) => {\n    //   const thisScale = scales[key];\n    //   const segments = [];\n    //   if (!thisScale.segments) {\n    //     return;\n    //   }\n    //   thisScale.segments.map(n => {\n    //     const min = n.min?n.min:thisScale.min; //if segment contains a min, set that as min. otherwise, set scale min as min.\n    //     const max = n.max?n.max:thisScale.max;\n    //     // console.log(xScales[i].scale(min));\n    //     segments.push(\n    //       {\n    //         scale: key,\n    //         yPos: thisScale.yPos,\n    //         segment: scaleLinear()\n    //         .domain([min, max])\n    //         .range([xScales[i].scale(min), xScales[i].scale(max)])\n    //       }\n    //     )\n    //   })\n    //   return segments;\n    // });\n\n    const xSegments = () => {\n      const segments = [];\n      Object.keys(scales).forEach((key, i) => {\n        const thisScale = scales[key]; // const segments = [];\n\n        if (!thisScale.segments) {\n          return;\n        }\n\n        thisScale.segments.map(n => {\n          const min = n.min ? n.min : thisScale.min; //if segment contains a min, set that as min. otherwise, set scale min as min.\n\n          const max = n.max ? n.max : thisScale.max; // console.log(xScales[i].scale(min));\n\n          segments.push({\n            scale: key,\n            yPos: thisScale.yPos,\n            proportion: (max - min) / (thisScale.max - thisScale.min),\n            segment: scaleLinear().domain([min, max]).range([xScales[key].scale(min), xScales[key].scale(max)])\n          });\n        });\n      });\n      return segments;\n    };\n    /*\n      xScales(generateScales(scaleLinear(scale)))\n      - take xScale and rescale according to transformations (newXScale)\n      - update each array entry's domain with that of newXScale\n    */\n    //if there is a zoom transform, override each xScales.scale with adjusted scale\n\n\n    if (currentZoomState) {\n      Object.entries(xScales).forEach(([key, thisScale]) => {\n        const newXScale = currentZoomState.rescaleX(thisScale.scale); //zoom state comes w methods for transformations\n        // const newXSegments = currentZoomState\n\n        xScales[key].scale = newXScale; //sets domain to newXScale domain\n      });\n    }\n\n    ; // const xScale = scaleLinear()\n    //   .domain([xMin, xMax]) //scaleLinear takes domain (data values) & maps onto range (screen pixel values)\n    //   .range([0, dimensions.width]);\n\n    const yScale = scaleLinear() //if difference in y vaules greater than 5, resize to min and max\n    .domain(rangeY > breakpoint ? [yMin, yMax] : [yMin - breakpoint, yMax + breakpoint]).range([0, dimensions.height]); //inverse scales for drag behavior\n    // const xScaleInverse = scaleLinear()\n    //   .domain([-dimensions.width, dimensions.width])\n    //   .range([-rangeX, rangeX]); //maxRangeX-minRangeX gives section of x values displayed onscreen\n\n    const yScaleInverse = scaleLinear().domain([-0, dimensions.height]).range(rangeY > breakpoint ? [yMin, yMax] : [yMin - breakpoint, yMax + breakpoint]);\n    const yScaleInverseDrag = scaleLinear().domain([-dimensions.height, dimensions.height]).range(rangeY > breakpoint ? [-rangeY, rangeY] : [-breakpoint * 5, breakpoint * 5]); //---draw zones---//\n\n    if (zones.length) {\n      svg.selectAll(\".zones\").data(zones).join(\"rect\").attr(\"class\", \"zones\").attr(\"x\", d => xScales[d.scale].scale(d.start)) // .attr(\"x\", n => generateScales(scales[n.scale]).x(n.start))\n      // .attr(\"y\", n => n.yStart ? yScale(n.yStart) : yScale(minMax[2]))\n      .attr(\"y\", n => n.yStart ? yScale(n.yStart) : 0) //todo\n      .attr(\"width\", d => xScales[d.scale].scale(d.end) - xScales[d.scale].scale(d.start)).attr(\"height\", n => {\n        if (n.yStart & n.yEnd) {\n          return yScale(n.yEnd) - yScale(n.yStart);\n        } else if (n.yStart) {\n          return yScale(yMax + 10) - yScale(n.yStart);\n        } else {\n          return yScale(yMax + 10); //todo\n          // return (yScale(minMax[3])-yScale(minMax[2]))\n        }\n      }).attr(\"opacity\", n => n.opacity ? n.opacity : 0.5).attr(\"fill\", n => n.color ? n.color : \"#999\").attr(\"stroke\", \"black\") //todo\n      .attr(\"stroke-width\", n => n.importance ? n.importance * 2 : 0).on(\"click\", (e, target) => {\n        //displays zone properties when clicked\n        if (toggle === \"certainty\" || toggle === \"importance\") {\n          setInflectTarget(target);\n        } else {\n          setInfo({\n            position: [e.x, e.y],\n            target: target,\n            type: \"zone\"\n          }); //todo: set info to null when clicking again\n        }\n\n        e.stopPropagation();\n      });\n    } //---draw bottom axis---//\n\n\n    xSegments().forEach(n => {\n      const segment = axisBottom(n.segment) // .ticks(n.proportion<.33?5:null, \"f\");\n      .ticks(null, \"f\");\n      svg.append(\"g\").attr(\"class\", \"remove\").style(\"transform\", `translateY(${dimensions.height * n.yPos}px)`).call(segment).raise().call(g => g.select(\".domain\") //removes solid black axis bar\n      .remove()).call(g => g.selectAll(\".tick line\") //styles individual ticks\n      .attr(\"stroke-opacity\", 0.5)).call(g => g.selectAll(\".tick text\").attr(\"y\", 10).attr(\"opacity\", (d, i) => {\n        //todo\n        if (n.proportion < .25 && i % 3) {\n          //less than 1/4, label every 3 ticks\n          return 0;\n        } else if (n.proportion < .33 && i % 2) {\n          //less than 1/3, label every other tick\n          return 0;\n        } else {\n          return 0.5;\n        }\n      }));\n    });\n    Object.entries(xScales).forEach(([key, thisScale]) => {\n      const xAxis = axisBottom(thisScale.scale).tickFormat(format(''));\n      svg.append(\"g\") //todo\n      .attr(\"class\", \"remove\").style(\"transform\", `translateY(${dimensions.height * thisScale.yPos}px)`).call(xAxis).raise().call(g => g.select(\".domain\") //removes solid black axis bar\n      .remove()).call(g => g.selectAll(\".tick line\") //styles individual ticks\n      .attr(\"stroke-opacity\", 0)).call(g => g.selectAll(\".tick text\").attr(\"y\", 10) //todo?\n      .attr(\"opacity\", 0));\n      svg.append(\"text\").text(thisScale.units).attr(\"class\", \"axisLabel smallTxt remove\").attr(\"x\", dimensions.width / 2).attr(\"y\", dimensions.height * (thisScale.yPos + .07)).attr(\"text-anchor\", \"middle\").attr(\"opacity\", 0.5);\n    }); // const xAxis = axisBottom(generateScales(scales.smalls).x)\n    //   // .tickSize(-dimensions.height) //tick extends to entire height of svg\n    //   .tickValues(logic ? [-1, 0, 1] : null)\n    //   .tickFormat(logic ? x => scaleOrdinal([-1, 0, 1], [\"before\", \"now\", \"after\"])(x) : format('')); //gets rid of , for 1000s groupings\n    // svg\n    //   .select(\".x-axis\") //selects and replaces .x-axis\n    //   .style(\"transform\", `translateY(${dimensions.height}px)`)\n    //   .call(xAxis)\n    //   .raise()\n    // .call(g => g.select(\".domain\") //removes solid black axis bar\n    //   .remove())\n    // .call(g => g.selectAll(\".tick line\") //styles individual ticks\n    //   .attr(\"stroke-opacity\", 0.5))\n    //   // .attr(\"stroke-dasharray\", \"2,2\"))\n    // .call(g => g.selectAll(\".tick text\")\n    //   .attr(\"y\", 10) //todo?\n    //   .attr(\"opacity\", 0.5));\n    //   // .attr(\"font-size\", fontSize*.8)); //replace class \"x-axis\" w xAxis\n    //\n    //--drag behavior--//\n\n    const dragged = drag() // .on(\"start\", e => {\n    //   select(this).attr(\"stroke\", \"black\");\n    // })\n    .on(\"drag\", e => {\n      //todo (round new position to .01)\n      const dx = generateScales(scales[e.subject.scale]).xInverseDrag(e.dx); // const dx = xScales.scaleInverse\n\n      const dy = yScaleInverseDrag(e.dy);\n      const newInstants = [...data]; //always make a copy when updating array\n      //find array element in data with matching ID and set new x y coordinates\n\n      newInstants.find(n => n.id === e.subject.id).x += dx;\n      newInstants.find(n => n.id === e.subject.id).y += dy;\n      setData(newInstants);\n    }); //---draw links---//\n\n    const linker = linkHorizontal().source(link => link.source).target(link => link.target) // .x(n => generateScales(scales[n.scale]).x(logic ? logicScale(n.x) : n.x))\n    .x(d => xScales[d.scale].scale(d.x)).y(d => yScale(d.y));\n    svg.selectAll(\".link\").data(links).join(\"path\").raise().attr(\"class\", \"link pointer\").attr(\"d\", linker).attr(\"fill\", \"none\").attr(\"stroke\", n => n.color ? n.color : \"black\").attr(\"stroke-width\", n => n.width ? n.width : radius / 3).attr(\"stroke-opacity\", n => n.opacity ? n.opacity : 1).attr(\"stroke-dasharray\", n => n.dashed ? n.dashed : null).on(\"click\", (e, target) => {\n      if (toggle === \"connection\") {\n        const newOrder = [...syntacticOrder];\n\n        if (newOrder[2] === 0) {\n          //set 2nd selection\n          newOrder[1] = {\n            x: generateScales(scales[activeScale]).xInverse(e.layerX),\n            y: yScaleInverse(e.layerY),\n            scale: activeScale\n          }; //scale TODO\n\n          newOrder[2] = 1;\n        } else {\n          //set 1st selection\n          newOrder[0] = {\n            x: generateScales(scales[activeScale]).xInverse(e.layerX),\n            y: yScaleInverse(e.layerY),\n            scale: activeScale\n          };\n          newOrder[2] = 0;\n        }\n\n        setSyntacticOrder(newOrder);\n      } //else if (toggle===\"foreshadowing\") {\n      //   if (!target.target) { //if target is an endpoint, indeterminate end\n      //\n      //\n      //   } else { //otherwise, change mouse to no symbol\n      //\n      //   }\n      //   //option to adjust gradient eventually\n      // } else\n      else if (toggle === \"certainty\" || toggle === \"importance\") {\n          setInflectTarget(target);\n        } else {\n          console.log(e);\n          setInfo({\n            position: [e.x, e.y],\n            target: target,\n            type: \"link\"\n          }); //displays interval properties when clicked\n        }\n\n      e.stopPropagation();\n    }); //---draw instants---//\n\n    svg.selectAll(\".instant\").data(activeData.filter(d => !d.foreshadowing && !d.cancelled)).join(\"circle\").raise().attr(\"class\", \"instant pointer\").attr(\"r\", n => n.radius ? n.radius : radius) //todo for accessibility\n    .attr(\"fill\", d => d.color ? d.color : \"black\") //if it has a color other than black, use that\n    .attr(\"opacity\", d => d.opacity ? d.opacity : 1) // .attr(\"cx\", d => generateScales(scales[d.scale]).x(logic ? logicScale(d.x) : d.x))\n    .attr(\"cx\", d => xScales[d.scale].scale(d.x)) //todo\n    .attr(\"cy\", d => yScale(d.y)).call(dragged).on(\"click\", (e, target) => {\n      switch (toggle) {\n        case \"cancelled\":\n          const newInstants = [...data];\n          const instant = newInstants.find(n => n.id === target.id);\n          instant.cancelled = true;\n          setData(newInstants);\n          break;\n\n        case \"connection\":\n          const newOrder = [...syntacticOrder];\n\n          if (newOrder[2] === 0) {\n            //set 2nd selection\n            newOrder[1] = target;\n            newOrder[2] = 1;\n          } else {\n            //set 1st selection\n            newOrder[0] = target;\n            newOrder[2] = 0;\n          }\n\n          setSyntacticOrder(newOrder);\n          break;\n\n        case \"foreshadowing\":\n          if (!target.target) {\n            //if target is an endpoint, indeterminate end\n            const newInstants = [...data];\n            const instant = newInstants.find(n => n.id === target.id);\n            instant.foreshadowing = true;\n            setData(newInstants);\n          } else {\n            //otherwise, change mouse to no symbol\n            console.log(\"forbidden\");\n          }\n\n          break;\n\n        case \"certainty\":\n          setInflectTarget(target);\n          break;\n\n        case \"importance\":\n          setInflectTarget(target);\n          break;\n\n        default:\n          setInfo({\n            position: [e.x, e.y],\n            target: target\n          });\n        //displays instant properties when clicked\n      } // if (toggle===\"cancelled\") {\n      //   const newInstants = [...data];\n      //   const instant = newInstants.find(n => n.id === target.id);\n      //   instant.cancelled = true;\n      //   setData(newInstants);\n      // } else if (){\n      //\n      // } else if (toggle===\"connection\") {\n      //   const newOrder = [...syntacticOrder];\n      //   if (newOrder[2]===0) { //set 2nd selection\n      //     newOrder[1] = target;\n      //     newOrder[2] = 1;\n      //   } else { //set 1st selection\n      //     newOrder[0] = target;\n      //     newOrder[2] = 0;\n      //   }\n      //   setSyntacticOrder(newOrder);\n      // } else if (toggle===\"foreshadowing\") { //todo: adjust gradient\n      //   if (!target.target) { //if target is an endpoint, indeterminate end\n      //     const newInstants = [...data];\n      //     const instant = newInstants.find(n => n.id === target.id);\n      //     instant.foreshadowing = true;\n      //     setData(newInstants);\n      //   } else { //otherwise, change mouse to no symbol\n      //     console.log(\"forbidden\");\n      //   }\n      // } else if (toggle===\"certainty\" || toggle===\"importance\"){\n      //   setInflectTarget(target);\n      // } else {\n      //   setInfo({position: [e.x, e.y], target: target}); //displays instant properties when clicked\n      // }\n\n\n      e.stopPropagation(); //stops deselect when bg is clicked\n    }); //---draw inflections---//\n    //--draw connetion inflection--//\n    //circle around instant\n\n    svg.selectAll(\".connections\").data(activeData.filter(d => d.connections)).join(\"circle\").raise().attr(\"class\", \"connections pointer\").attr(\"r\", n => n.radius ? n.radius * 1.5 : radius * 2) //todo for accessibility\n    .attr(\"fill\", \"none\").attr(\"stroke\", \"black\").attr(\"stroke-dasharray\", \"3\") // .attr(\"opacity\", d => d.opacity ? d.opacity : 1)\n    .attr(\"cx\", d => xScales[d.scale].scale(d.x)) //todo\n    .attr(\"cy\", d => yScale(d.y)); //link connecting circles\n\n    const ctLinker = linkHorizontal().source(instant => data.find(x => x.id === instant.id)).target(instant => typeof instant.connections[0] === \"object\" ? instant.connections[0] : data.find(x => x.id === instant.connections[0])) // .target(() => {\n    //   //layerX, layerY\n    //   const y = yScaleInverse(499);\n    //   const x = xScales.find(n => n.name === \"biggie\").scaleInverse(778)\n    //   return {x: x, y: y}\n    // })\n    // .target(instant => data.find(x => x.id === instant.connections[0]))\n    .x(d => d.scale ? xScales[d.scale].scale(d.x) : d.x).y(d => d.scale ? yScale(d.y) : d.y);\n    svg.selectAll(\".connectionLinks\").data(activeData.filter(n => n.connections && !n.connections[1])) //link starts from 1st one\n    .join(\"path\").raise().attr(\"class\", \"connectionLinks pointer\").attr(\"d\", ctLinker).attr(\"fill\", \"none\").attr(\"stroke\", \"black\") // .attr(\"stroke\", n => n.color? n.color : \"black\")\n    // .attr(\"stroke-opacity\", n => n.opacity ? n.opacity : 1)\n    .attr(\"stroke-dasharray\", \"3\"); //initialize custom symbols\n\n    const cancelledSymbol = {\n      draw: (context, size) => {\n        let s = Math.sqrt(size) / 2;\n        context.moveTo(s, 0);\n        context.lineTo(s * 2, s);\n        context.lineTo(s, s * 2);\n        context.lineTo(0, s);\n        context.lineTo(-s, s * 2);\n        context.lineTo(-s * 2, s);\n        context.lineTo(-s, 0);\n        context.lineTo(-s * 2, -s);\n        context.lineTo(-s, -s * 2);\n        context.lineTo(0, -s);\n        context.lineTo(s, -s * 2);\n        context.lineTo(s * 2, -s);\n        context.closePath();\n      }\n    }; //foreshadowing symbol\n\n    const fsSymbol = {\n      draw: (context, size) => {\n        let s = size;\n        context.moveTo(0, 0);\n        context.lineTo(s * 2, s / 2);\n        context.lineTo(s * 2, -s / 2);\n        context.closePath();\n      }\n    }; //foreshadowing gradient\n\n    var fsg = svg.append(\"defs\").append(\"linearGradient\").attr(\"id\", \"fsgradient\") //id of the gradient\n    .attr(\"x1\", \"0%\").attr(\"x2\", \"100%\") //since its a horizontal linear gradient\n    .attr(\"y1\", \"0%\").attr(\"y2\", \"0%\");\n    fsg.append(\"stop\").attr(\"offset\", \"0%\").style(\"stop-color\", \"black\") //start in black. TODO\n    .style(\"stop-opacity\", 1);\n    fsg.append(\"stop\").attr(\"offset\", \"100%\").style(\"stop-color\", \"black\") //end in transparent\n    .style(\"stop-opacity\", 0); //---draw symbols---//\n    //todo: doesn't work when cancelled is true from the start\n\n    svg.selectAll(\".cancelled\").data(activeData.filter(d => d.cancelled)).join(\"path\").raise().attr(\"class\", \"cancelled pointer\").attr(\"d\", symbol(cancelledSymbol, radius * radius * 5)).attr(\"fill\", d => d.color ? d.color : \"black\") //if it has a color other than black, use that\n    .attr(\"transform\", d => `translate(${xScales[d.scale].scale(d.x)}, ${yScale(d.y)})`).on(\"click\", (e, target) => {\n      if (toggle === \"cancelled\") {\n        const newInstants = [...data];\n        const instant = newInstants.find(n => n.id === target.id);\n        delete instant.cancelled;\n        setData(newInstants);\n      } else {\n        setInfo({\n          position: [e.x, e.y],\n          target: target\n        }); //displays instant properties when clicked\n      }\n\n      e.stopPropagation();\n    }); //---draw foreshadowing---//\n\n    svg.selectAll(\".foreshadowing\").data(activeData.filter(d => d.foreshadowing)).join(\"path\").raise().attr(\"class\", \"foreshadowing pointer\").attr(\"d\", symbol(fsSymbol, radius * radius * 5)).style(\"fill\", \"url(#fsgradient)\").attr(\"transform\", d => `translate(${xScales[d.scale].scale(d.x)}, ${yScale(d.y)})`).on(\"click\", (e, target) => {\n      if (toggle === \"foreshadowing\") {\n        const newInstants = [...data];\n        const instant = newInstants.find(n => n.id === target.id);\n        delete instant.foreshadowing;\n        setData(newInstants);\n      } else {\n        setInfo({\n          position: [e.x, e.y],\n          target: target\n        }); //displays instant properties when clicked\n      }\n\n      e.stopPropagation();\n    }); //---draw labels---//\n\n    svg.selectAll(\".label\").data(activeData).join(\"text\").raise().attr(\"class\", \"label\").text(instant => showLabel ? instant.name : instant.id).attr(\"x\", d => xScales[d.scale].scale(d.x)).attr(\"y\", d => yScale(d.y + (rangeY > breakpoint ? rangeY * .06 : breakpoint / 5))) //vertical offset. see scales\n    .attr(\"text-anchor\", \"middle\"); // .attr(\"font-size\", fontSize);\n    //---zoom---//\n\n    const zoomBehavior = zoom().scaleExtent([0.25, 5]) //can zoom 2x smaller and 5x bigger\n    .translateExtent([[-50, 0], [dimensions.width + 50, dimensions.height]]) //limits how far graph can pan\n    .on(\"zoom\", e => {\n      const zoomState = e.transform; //returns zoom transformations as an object\n\n      setCurrentZoomState(zoomState);\n    }); //regular clicking\n\n    svg.on(\"click\", e => {\n      if (toggle === \"addInstant\") {\n        const x = generateScales(scales[activeScale]).xInverse(e.layerX);\n        const y = yScaleInverse(e.layerY);\n        setInflectTarget({\n          x: x,\n          y: y\n        });\n        setToggle(\"NewInstantForm\");\n      }\n\n      setInfo(null);\n    });\n    svg.call(zoomBehavior);\n  }, [data, setData, zones, scales, toggle, activeLayer, activeData, dimensions, logic, currentZoomState, setInfo, radius, showLabel, syntacticOrder]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: wrapperRef,\n    className: \"svgWrapper\",\n    children: /*#__PURE__*/_jsxDEV(\"svg\", {\n      id: \"graphic\",\n      ref: svgRef\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 693,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 692,\n    columnNumber: 5\n  }, this);\n}\n\n_s(Graphic, \"/KiWkGO4xuCDaFbcDOaAf23vnZg=\", false, function () {\n  return [useResizeObserver];\n});\n\n_c = Graphic;\n;\nexport default Graphic;\n\nvar _c;\n\n$RefreshReg$(_c, \"Graphic\");","map":{"version":3,"sources":["/Users/skye/Desktop/Portfolio/2021/chronologies/client/src/components/Graphic.js"],"names":["React","useState","useEffect","useRef","select","scaleLinear","scaleOrdinal","axisBottom","linkHorizontal","format","drag","zoom","min","max","symbol","symbols","useResizeObserver","generateLinks","Graphic","data","setData","activeLayer","zones","setZones","radius","info","setInfo","setInflectTarget","showLabel","toggle","setToggle","scales","setScales","syntacticOrder","setSyntacticOrder","activeScale","activeData","filter","d","layer","logic","isNaN","x","svgRef","wrapperRef","dimensions","currentZoomState","setCurrentZoomState","links","svg","current","selectAll","remove","logicScale","unknown","breakpoint","xMin","map","xMax","yMin","y","yMax","rangeX","rangeY","generateScales","currentScale","domain","range","width","height","xInverse","xInverseDrag","yInverse","xScales","Object","fromEntries","entries","key","thisScale","scale","yPos","units","scaleInverse","xSegments","segments","keys","forEach","i","n","push","proportion","segment","newXScale","rescaleX","yScale","yScaleInverse","yScaleInverseDrag","length","join","attr","start","yStart","end","yEnd","opacity","color","importance","on","e","target","position","type","stopPropagation","ticks","append","style","call","raise","g","xAxis","tickFormat","text","dragged","dx","subject","dy","newInstants","find","id","linker","source","link","dashed","newOrder","layerX","layerY","console","log","foreshadowing","cancelled","instant","connections","ctLinker","cancelledSymbol","draw","context","size","s","Math","sqrt","moveTo","lineTo","closePath","fsSymbol","fsg","name","zoomBehavior","scaleExtent","translateExtent","zoomState","transform"],"mappings":"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","sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\nimport { select, scaleLinear, scaleOrdinal, axisBottom, linkHorizontal, format, drag, zoom, min, max, symbol, symbols } from \"d3\";\nimport useResizeObserver from \"./useResizeObserver\";\nimport generateLinks from \"./generateLinks\";\n\nfunction Graphic({\n  data, setData,\n  activeLayer,\n  zones, setZones,\n  radius,\n  info, setInfo,\n  setInflectTarget,\n  showLabel,\n  toggle, setToggle,\n  scales, setScales,\n  syntacticOrder, setSyntacticOrder,\n  activeScale\n}) {\n\n  //all data is passed down from and synced to App.js\n  const activeData = activeLayer ? data.filter(d => d.layer === activeLayer) : data;\n\n  //is logical operators active?\n  const logic = isNaN(data[0].x); //Todo\n\n  //initialize reference object to pass to svg in React Dom\n  const svgRef = useRef();\n  //svg wrapped in div bc otherwise resize observer callback won't work\n  const wrapperRef = useRef();\n  const dimensions = useResizeObserver(wrapperRef);\n  const [currentZoomState, setCurrentZoomState] = useState();\n\n  // //initialize links between instants\n  const links = generateLinks(activeData);\n\n  //all d3 shennanigans goes in this hook. called initially and on every data change\n  useEffect(() => {\n    const svg = select(svgRef.current); //\"svg\" is the current version of svgRef data\n    //prevents crashing when useResizeObserver returns null before svg is rendered\n    if (!dimensions) return;\n    //removes svgs added using append()\n    svg\n      .selectAll(\".remove\")\n      .remove();\n\n    //initialize inflections for .selectAll\n    //add cancelled class\n\n    //---scales---//\n\n    //if time matches logical operator keyword, translate into index values, then map\n    const logicScale = scaleOrdinal([\"before\", \"now\", \"after\"], [-1, 0, 1]).unknown(0);\n\n    const breakpoint = 5;\n\n\n    const xMin = min(data.map(({x}) => logic ? logicScale(x) : x));\n    const xMax = max(data.map(({x}) => logic ? logicScale(x) : x));\n    const yMin = min(data.map(({y}) => y));\n    const yMax = max(data.map(({y}) => y));\n    const rangeX = xMax-xMin; //0 is minX, 1 is maxX (reference findMinMax)\n    const rangeY = yMax-yMin;\n\n\n    //TODO: scaleTime()\n\n    //for multiple scales, generate a new scale for each x/y min - x/y max\n    /*\n    - Allow users to specify scale. x&y min max and units\n    - for each scale, generateScale()\n\n    */\n\n    function generateScales(currentScale) {\n\n      const x = scaleLinear()\n        .domain([currentScale.min, currentScale.max]) //scaleLinear takes domain (data values) & maps onto range (screen pixel values)\n        .range([0, dimensions.width])\n      const y = scaleLinear()\n        //if difference in y vaules greater than 5, resize to min and max\n        .domain((rangeY>breakpoint) ? [yMin, yMax] : [yMin-breakpoint, yMax+breakpoint])\n        .range([0, dimensions.height])\n      const xInverse = scaleLinear()\n        .domain([0, dimensions.width])\n        .range([currentScale.min, currentScale.max]) //maxRangeX-minRangeX gives section of x values displayed onscreen\n      const xInverseDrag = scaleLinear()\n        .domain([-dimensions.width, dimensions.width])\n        .range([-(currentScale.max-currentScale.min), (currentScale.max-currentScale.min)]) //maxRangeX-minRangeX gives section of x values displayed onscreen\n      const yInverse = scaleLinear()\n        .domain([-dimensions.height, dimensions.height])\n        .range((rangeY>breakpoint) ? [-rangeY, rangeY] : [-breakpoint*5, breakpoint*5])\n\n\n      return {\n        x, y, xInverse, xInverseDrag, yInverse\n      };\n    }\n\n    //scales values to screen pixels\n    /*\n    {\n      biggie: {\n        ...\n        scale: generateScale()\n      }\n      ...\n    }\n    */\n    // const xScales = () => {\n    //   Object.keys(scales).forEach(key => { //for every scale in scales data, generate an xScale\n    //     // const thisScale = scales[key];\n    //     scales[key] = {...scales[key], scale:generateScales(scales[key]).x}\n    //   });\n    //   return scales;\n    // }\n\n    const xScales = Object.fromEntries(\n      Object.entries(scales).map(([key, thisScale]) => [\n        key,\n        {\n          scale: scaleLinear() //scaleLinear takes domain (data values) & maps onto range (screen pixel values)\n            .domain([thisScale.min, thisScale.max])\n            .range([0, dimensions.width]),\n          // segments: thisScale.segments.map(n => {\n          //   scaleLinear() //scaleLinear takes domain (data values) & maps onto range (screen pixel values)\n          //     .domain([thisScale.min, thisScale.max])\n          //     .range([0, dimensions.width])\n          // }),\n          yPos: thisScale.yPos,\n          units: thisScale.units,\n          scaleInverse: scaleLinear() //scaleLinear takes domain (data values) & maps onto range (screen pixel values)\n            .domain([-dimensions.width, dimensions.width])\n            .range([-(thisScale.max-thisScale.min), (thisScale.max-thisScale.min)])\n        }\n      ])\n    );\n\n    // const xScales = Object.keys(scales).map(key => { //for every scale in scales data, generate an xScale\n    //   const thisScale = scales[key];\n    //   return ({\n    //     name: key,\n    //     scale: scaleLinear() //scaleLinear takes domain (data values) & maps onto range (screen pixel values)\n    //       .domain([thisScale.min, thisScale.max])\n    //       .range([0, dimensions.width]),\n    //     // segments: thisScale.segments.map(n => {\n    //     //   scaleLinear() //scaleLinear takes domain (data values) & maps onto range (screen pixel values)\n    //     //     .domain([thisScale.min, thisScale.max])\n    //     //     .range([0, dimensions.width])\n    //     // }),\n    //     yPos: thisScale.yPos,\n    //     units: thisScale.units,\n    //     scaleInverse: scaleLinear() //scaleLinear takes domain (data values) & maps onto range (screen pixel values)\n    //       .domain([-dimensions.width, dimensions.width])\n    //       .range([-(thisScale.max-thisScale.min), (thisScale.max-thisScale.min)])\n    //   })\n    // });\n    //\n\n\n    // const xSegments = Object.keys(scales).map((key, i) => {\n    //   const thisScale = scales[key];\n    //   const segments = [];\n    //   if (!thisScale.segments) {\n    //     return;\n    //   }\n    //   thisScale.segments.map(n => {\n    //     const min = n.min?n.min:thisScale.min; //if segment contains a min, set that as min. otherwise, set scale min as min.\n    //     const max = n.max?n.max:thisScale.max;\n    //     // console.log(xScales[i].scale(min));\n    //     segments.push(\n    //       {\n    //         scale: key,\n    //         yPos: thisScale.yPos,\n    //         segment: scaleLinear()\n    //         .domain([min, max])\n    //         .range([xScales[i].scale(min), xScales[i].scale(max)])\n    //       }\n    //     )\n    //   })\n    //   return segments;\n    // });\n\n    const xSegments = () => {\n      const segments = [];\n      Object.keys(scales).forEach((key, i) => {\n        const thisScale = scales[key];\n        // const segments = [];\n        if (!thisScale.segments) {\n          return;\n        }\n        thisScale.segments.map(n => {\n          const min = n.min?n.min:thisScale.min; //if segment contains a min, set that as min. otherwise, set scale min as min.\n          const max = n.max?n.max:thisScale.max;\n          // console.log(xScales[i].scale(min));\n          segments.push({\n            scale: key,\n            yPos: thisScale.yPos,\n            proportion: (max-min)/(thisScale.max-thisScale.min),\n            segment: scaleLinear()\n            .domain([min, max])\n            .range([xScales[key].scale(min), xScales[key].scale(max)])\n          })\n        })\n      });\n      return segments;\n    }\n\n\n    /*\n      xScales(generateScales(scaleLinear(scale)))\n      - take xScale and rescale according to transformations (newXScale)\n      - update each array entry's domain with that of newXScale\n    */\n    //if there is a zoom transform, override each xScales.scale with adjusted scale\n    if (currentZoomState) {\n      Object.entries(xScales).forEach(([key,thisScale]) => {\n        const newXScale = currentZoomState.rescaleX(thisScale.scale); //zoom state comes w methods for transformations\n        // const newXSegments = currentZoomState\n        xScales[key].scale = newXScale; //sets domain to newXScale domain\n\n      });\n\n\n    };\n    // const xScale = scaleLinear()\n    //   .domain([xMin, xMax]) //scaleLinear takes domain (data values) & maps onto range (screen pixel values)\n    //   .range([0, dimensions.width]);\n    const yScale = scaleLinear()\n      //if difference in y vaules greater than 5, resize to min and max\n      .domain((rangeY>breakpoint) ? [yMin, yMax] : [yMin-breakpoint, yMax+breakpoint])\n      .range([0, dimensions.height]);\n    //inverse scales for drag behavior\n    // const xScaleInverse = scaleLinear()\n    //   .domain([-dimensions.width, dimensions.width])\n    //   .range([-rangeX, rangeX]); //maxRangeX-minRangeX gives section of x values displayed onscreen\n    const yScaleInverse = scaleLinear()\n      .domain([-0, dimensions.height])\n      .range((rangeY>breakpoint) ? [yMin, yMax] : [yMin-breakpoint, yMax+breakpoint]);\n    const yScaleInverseDrag = scaleLinear()\n      .domain([-dimensions.height, dimensions.height])\n      .range((rangeY>breakpoint) ? [-rangeY, rangeY] : [-breakpoint*5, breakpoint*5]);\n\n\n\n\n\n    //---draw zones---//\n    if (zones.length) {\n      svg\n      .selectAll(\".zones\")\n      .data(zones)\n      .join(\"rect\")\n      .attr(\"class\", \"zones\")\n      .attr(\"x\", d => xScales[d.scale].scale(d.start))\n      // .attr(\"x\", n => generateScales(scales[n.scale]).x(n.start))\n      // .attr(\"y\", n => n.yStart ? yScale(n.yStart) : yScale(minMax[2]))\n      .attr(\"y\", n => n.yStart ? yScale(n.yStart) : 0) //todo\n      .attr(\"width\", d => xScales[d.scale].scale(d.end) - xScales[d.scale].scale(d.start))\n      .attr(\"height\", n => {\n        if (n.yStart & n.yEnd) {\n          return (yScale(n.yEnd)-yScale(n.yStart))\n        } else if (n.yStart) {\n          return (yScale(yMax+10)-yScale(n.yStart))\n        } else {\n          return (yScale(yMax+10)) //todo\n          // return (yScale(minMax[3])-yScale(minMax[2]))\n        }})\n      .attr(\"opacity\", n => n.opacity ? n.opacity : 0.5)\n      .attr(\"fill\", n => n.color ? n.color : \"#999\")\n      .attr(\"stroke\", \"black\") //todo\n      .attr(\"stroke-width\", n => n.importance ? n.importance*2 : 0)\n      .on(\"click\", (e, target) => {\n        //displays zone properties when clicked\n        if (toggle===\"certainty\" || toggle===\"importance\") {\n          setInflectTarget(target);\n        } else {\n          setInfo({position: [e.x, e.y], target: target, type: \"zone\"});  //todo: set info to null when clicking again\n        }\n        e.stopPropagation();\n      });\n    }\n\n    //---draw bottom axis---//\n\n    xSegments().forEach(n => {\n      const segment = axisBottom(n.segment)\n      // .ticks(n.proportion<.33?5:null, \"f\");\n      .ticks(null, \"f\");\n\n      svg\n        .append(\"g\")\n        .attr(\"class\", \"remove\")\n        .style(\"transform\", `translateY(${dimensions.height*n.yPos}px)`)\n        .call(segment)\n        .raise()\n        .call(g => g.select(\".domain\") //removes solid black axis bar\n          .remove())\n        .call(g => g.selectAll(\".tick line\") //styles individual ticks\n          .attr(\"stroke-opacity\", 0.5))\n        .call(g => g.selectAll(\".tick text\")\n          .attr(\"y\", 10)\n          .attr(\"opacity\", (d, i) => { //todo\n            if ((n.proportion<.25)&&(i%3)) { //less than 1/4, label every 3 ticks\n              return 0;\n            } else if ((n.proportion<.33)&&(i%2)) { //less than 1/3, label every other tick\n              return 0;\n            } else {\n              return 0.5\n            }\n          })\n        );\n    });\n\n    Object.entries(xScales).forEach(([key,thisScale]) => {\n      const xAxis = axisBottom(thisScale.scale)\n      .tickFormat(format(''));\n\n      svg\n        .append(\"g\") //todo\n        .attr(\"class\", \"remove\")\n        .style(\"transform\", `translateY(${dimensions.height*thisScale.yPos}px)`)\n        .call(xAxis)\n        .raise()\n        .call(g => g.select(\".domain\") //removes solid black axis bar\n          .remove())\n        .call(g => g.selectAll(\".tick line\") //styles individual ticks\n          .attr(\"stroke-opacity\", 0))\n        .call(g => g.selectAll(\".tick text\")\n          .attr(\"y\", 10) //todo?\n          .attr(\"opacity\", 0));\n      svg\n        .append(\"text\")\n        .text(thisScale.units)\n        .attr(\"class\", \"axisLabel smallTxt remove\")\n        .attr(\"x\", dimensions.width/2)\n        .attr(\"y\", dimensions.height*(thisScale.yPos+.07))\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"opacity\", 0.5);\n      }\n    );\n\n\n    // const xAxis = axisBottom(generateScales(scales.smalls).x)\n    //   // .tickSize(-dimensions.height) //tick extends to entire height of svg\n    //   .tickValues(logic ? [-1, 0, 1] : null)\n    //   .tickFormat(logic ? x => scaleOrdinal([-1, 0, 1], [\"before\", \"now\", \"after\"])(x) : format('')); //gets rid of , for 1000s groupings\n\n    // svg\n    //   .select(\".x-axis\") //selects and replaces .x-axis\n    //   .style(\"transform\", `translateY(${dimensions.height}px)`)\n    //   .call(xAxis)\n    //   .raise()\n      // .call(g => g.select(\".domain\") //removes solid black axis bar\n      //   .remove())\n      // .call(g => g.selectAll(\".tick line\") //styles individual ticks\n      //   .attr(\"stroke-opacity\", 0.5))\n      //   // .attr(\"stroke-dasharray\", \"2,2\"))\n      // .call(g => g.selectAll(\".tick text\")\n      //   .attr(\"y\", 10) //todo?\n      //   .attr(\"opacity\", 0.5));\n      //   // .attr(\"font-size\", fontSize*.8)); //replace class \"x-axis\" w xAxis\n    //\n\n    //--drag behavior--//\n    const dragged = drag()\n      // .on(\"start\", e => {\n      //   select(this).attr(\"stroke\", \"black\");\n      // })\n      .on(\"drag\", e => {\n        //todo (round new position to .01)\n        const dx = generateScales(scales[e.subject.scale]).xInverseDrag(e.dx);\n        // const dx = xScales.scaleInverse\n        const dy = yScaleInverseDrag(e.dy);\n        const newInstants = [...data]; //always make a copy when updating array\n        //find array element in data with matching ID and set new x y coordinates\n        newInstants.find(n => n.id === e.subject.id).x += dx;\n        newInstants.find(n => n.id === e.subject.id).y += dy;\n        setData(newInstants);\n      });\n\n    //---draw links---//\n    const linker = linkHorizontal()\n      .source(link => link.source)\n      .target(link => link.target)\n      // .x(n => generateScales(scales[n.scale]).x(logic ? logicScale(n.x) : n.x))\n      .x(d => xScales[d.scale].scale(d.x))\n      .y(d => yScale(d.y));\n\n    svg\n      .selectAll(\".link\")\n      .data(links)\n      .join(\"path\")\n      .raise()\n      .attr(\"class\", \"link pointer\")\n      .attr(\"d\", linker)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", n => n.color? n.color : \"black\")\n      .attr(\"stroke-width\", n => n.width ? n.width : radius/3)\n      .attr(\"stroke-opacity\", n => n.opacity ? n.opacity : 1)\n      .attr(\"stroke-dasharray\", n => n.dashed ? n.dashed : null)\n      .on(\"click\", (e, target) => {\n        if (toggle===\"connection\") {\n          const newOrder = [...syntacticOrder];\n          if (newOrder[2]===0) { //set 2nd selection\n            newOrder[1] = {x:generateScales(scales[activeScale]).xInverse(e.layerX), y:yScaleInverse(e.layerY), scale:activeScale}; //scale TODO\n            newOrder[2] = 1;\n          } else { //set 1st selection\n            newOrder[0] = {x:generateScales(scales[activeScale]).xInverse(e.layerX), y:yScaleInverse(e.layerY), scale:activeScale};\n            newOrder[2] = 0;\n          }\n          setSyntacticOrder(newOrder);\n        }\n        //else if (toggle===\"foreshadowing\") {\n        //   if (!target.target) { //if target is an endpoint, indeterminate end\n        //\n        //\n        //   } else { //otherwise, change mouse to no symbol\n        //\n        //   }\n        //   //option to adjust gradient eventually\n        // } else\n        else if (toggle===\"certainty\" || toggle===\"importance\") {\n          setInflectTarget(target);\n        } else {\n          console.log(e)\n          setInfo({position: [e.x, e.y], target: target, type: \"link\"}); //displays interval properties when clicked\n        }\n        e.stopPropagation();\n      });\n\n\n    //---draw instants---//\n    svg\n      .selectAll(\".instant\")\n      .data(activeData.filter(d => !d.foreshadowing && !d.cancelled))\n      .join(\"circle\")\n      .raise()\n      .attr(\"class\", \"instant pointer\")\n      .attr(\"r\", n => n.radius? n.radius : radius) //todo for accessibility\n      .attr(\"fill\", d => d.color ? d.color : \"black\") //if it has a color other than black, use that\n      .attr(\"opacity\", d => d.opacity ? d.opacity : 1)\n      // .attr(\"cx\", d => generateScales(scales[d.scale]).x(logic ? logicScale(d.x) : d.x))\n      .attr(\"cx\", d => xScales[d.scale].scale(d.x)) //todo\n      .attr(\"cy\", d => yScale(d.y))\n      .call(dragged)\n      .on(\"click\", (e, target) => {\n        switch (toggle) {\n          case \"cancelled\":\n            const newInstants = [...data];\n            const instant = newInstants.find(n => n.id === target.id);\n            instant.cancelled = true;\n            setData(newInstants);\n            break;\n          case \"connection\":\n            const newOrder = [...syntacticOrder];\n            if (newOrder[2]===0) { //set 2nd selection\n              newOrder[1] = target;\n              newOrder[2] = 1;\n            } else { //set 1st selection\n              newOrder[0] = target;\n              newOrder[2] = 0;\n            }\n            setSyntacticOrder(newOrder);\n            break;\n          case \"foreshadowing\":\n            if (!target.target) { //if target is an endpoint, indeterminate end\n              const newInstants = [...data];\n              const instant = newInstants.find(n => n.id === target.id);\n              instant.foreshadowing = true;\n              setData(newInstants);\n            } else { //otherwise, change mouse to no symbol\n              console.log(\"forbidden\");\n            }\n            break;\n          case \"certainty\":\n            setInflectTarget(target);\n            break;\n          case \"importance\":\n            setInflectTarget(target);\n            break;\n          default:\n            setInfo({position: [e.x, e.y], target: target}); //displays instant properties when clicked\n        }\n        // if (toggle===\"cancelled\") {\n        //   const newInstants = [...data];\n        //   const instant = newInstants.find(n => n.id === target.id);\n        //   instant.cancelled = true;\n        //   setData(newInstants);\n        // } else if (){\n        //\n        // } else if (toggle===\"connection\") {\n        //   const newOrder = [...syntacticOrder];\n        //   if (newOrder[2]===0) { //set 2nd selection\n        //     newOrder[1] = target;\n        //     newOrder[2] = 1;\n        //   } else { //set 1st selection\n        //     newOrder[0] = target;\n        //     newOrder[2] = 0;\n        //   }\n        //   setSyntacticOrder(newOrder);\n        // } else if (toggle===\"foreshadowing\") { //todo: adjust gradient\n        //   if (!target.target) { //if target is an endpoint, indeterminate end\n        //     const newInstants = [...data];\n        //     const instant = newInstants.find(n => n.id === target.id);\n        //     instant.foreshadowing = true;\n        //     setData(newInstants);\n        //   } else { //otherwise, change mouse to no symbol\n        //     console.log(\"forbidden\");\n        //   }\n        // } else if (toggle===\"certainty\" || toggle===\"importance\"){\n        //   setInflectTarget(target);\n        // } else {\n        //   setInfo({position: [e.x, e.y], target: target}); //displays instant properties when clicked\n        // }\n        e.stopPropagation(); //stops deselect when bg is clicked\n      });\n\n    //---draw inflections---//\n\n    //--draw connetion inflection--//\n    //circle around instant\n    svg\n      .selectAll(\".connections\")\n      .data(activeData.filter(d => d.connections))\n      .join(\"circle\")\n      .raise()\n      .attr(\"class\", \"connections pointer\")\n      .attr(\"r\", n => n.radius? n.radius*1.5 : radius*2) //todo for accessibility\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", \"black\")\n      .attr(\"stroke-dasharray\", \"3\")\n      // .attr(\"opacity\", d => d.opacity ? d.opacity : 1)\n      .attr(\"cx\", d => xScales[d.scale].scale(d.x)) //todo\n      .attr(\"cy\", d => yScale(d.y));\n\n    //link connecting circles\n    const ctLinker = linkHorizontal()\n      .source(instant => data.find(x => x.id === instant.id))\n      .target(instant => typeof(instant.connections[0])===\"object\" ? instant.connections[0] : data.find(x => x.id === instant.connections[0]))\n      // .target(() => {\n      //   //layerX, layerY\n      //   const y = yScaleInverse(499);\n      //   const x = xScales.find(n => n.name === \"biggie\").scaleInverse(778)\n      //   return {x: x, y: y}\n      // })\n      // .target(instant => data.find(x => x.id === instant.connections[0]))\n      .x(d => d.scale ? xScales[d.scale].scale(d.x) : d.x)\n      .y(d => d.scale ? yScale(d.y) : d.y);\n    svg\n      .selectAll(\".connectionLinks\")\n      .data(activeData.filter(n => n.connections && !n.connections[1])) //link starts from 1st one\n      .join(\"path\")\n      .raise()\n      .attr(\"class\", \"connectionLinks pointer\")\n      .attr(\"d\", ctLinker)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", \"black\")\n      // .attr(\"stroke\", n => n.color? n.color : \"black\")\n      // .attr(\"stroke-opacity\", n => n.opacity ? n.opacity : 1)\n      .attr(\"stroke-dasharray\", \"3\")\n\n    //initialize custom symbols\n    const cancelledSymbol = {\n      draw: (context, size) => {\n        let s = Math.sqrt(size)/2;\n            context.moveTo(s,0);\n            context.lineTo(s*2,s);\n            context.lineTo(s,s*2);\n            context.lineTo(0,s);\n            context.lineTo(-s,s*2);\n            context.lineTo(-s*2,s);\n            context.lineTo(-s,0);\n            context.lineTo(-s*2,-s);\n            context.lineTo(-s,-s*2);\n            context.lineTo(0,-s);\n            context.lineTo(s,-s*2);\n            context.lineTo(s*2,-s);\n            context.closePath();\n      }\n    };\n    //foreshadowing symbol\n    const fsSymbol = {\n      draw: (context, size) => {\n        let s = size;\n            context.moveTo(0,0);\n            context.lineTo(s*2,s/2);\n            context.lineTo(s*2,-s/2);\n            context.closePath();\n      }\n    };\n    //foreshadowing gradient\n    var fsg = svg.append(\"defs\").append(\"linearGradient\")\n    .attr(\"id\", \"fsgradient\")//id of the gradient\n    .attr(\"x1\", \"0%\")\n    .attr(\"x2\", \"100%\") //since its a horizontal linear gradient\n    .attr(\"y1\", \"0%\")\n    .attr(\"y2\", \"0%\");\n\n    fsg.append(\"stop\")\n    .attr(\"offset\", \"0%\")\n    .style(\"stop-color\", \"black\")//start in black. TODO\n    .style(\"stop-opacity\", 1);\n\n    fsg.append(\"stop\")\n    .attr(\"offset\", \"100%\")\n    .style(\"stop-color\", \"black\")//end in transparent\n    .style(\"stop-opacity\", 0);\n\n    //---draw symbols---//\n    //todo: doesn't work when cancelled is true from the start\n    svg\n      .selectAll(\".cancelled\")\n      .data(activeData.filter(d => d.cancelled))\n      .join(\"path\")\n      .raise()\n      .attr(\"class\", \"cancelled pointer\")\n      .attr(\"d\", symbol(cancelledSymbol, radius*radius*5))\n      .attr(\"fill\", d => d.color ? d.color : \"black\") //if it has a color other than black, use that\n      .attr(\"transform\", d => `translate(${xScales[d.scale].scale(d.x)}, ${yScale(d.y)})`)\n      .on(\"click\", (e, target) => {\n        if (toggle===\"cancelled\") {\n          const newInstants = [...data];\n          const instant = newInstants.find(n => n.id === target.id);\n          delete instant.cancelled;\n          setData(newInstants);\n        } else {\n          setInfo({position: [e.x, e.y], target: target}); //displays instant properties when clicked\n        }\n        e.stopPropagation();\n      });\n\n    //---draw foreshadowing---//\n    svg\n      .selectAll(\".foreshadowing\")\n      .data(activeData.filter(d => d.foreshadowing))\n      .join(\"path\")\n      .raise()\n      .attr(\"class\", \"foreshadowing pointer\")\n      .attr(\"d\", symbol(fsSymbol, radius*radius*5))\n      .style(\"fill\", \"url(#fsgradient)\")\n      .attr(\"transform\", d => `translate(${xScales[d.scale].scale(d.x)}, ${yScale(d.y)})`)\n      .on(\"click\", (e, target) => {\n        if (toggle===\"foreshadowing\") {\n          const newInstants = [...data];\n          const instant = newInstants.find(n => n.id === target.id);\n          delete instant.foreshadowing;\n          setData(newInstants);\n        } else {\n          setInfo({position: [e.x, e.y], target: target}); //displays instant properties when clicked\n        }\n        e.stopPropagation();\n      });\n\n    //---draw labels---//\n    svg\n      .selectAll(\".label\")\n      .data(activeData)\n      .join(\"text\")\n      .raise()\n      .attr(\"class\", \"label\")\n      .text(instant => showLabel ? instant.name : instant.id)\n      .attr(\"x\", d => xScales[d.scale].scale(d.x))\n      .attr(\"y\", d => yScale(d.y + (rangeY>breakpoint ? rangeY*.06 : breakpoint/5))) //vertical offset. see scales\n      .attr(\"text-anchor\", \"middle\");\n      // .attr(\"font-size\", fontSize);\n\n\n    //---zoom---//\n    const zoomBehavior = zoom()\n      .scaleExtent([0.25, 5]) //can zoom 2x smaller and 5x bigger\n      .translateExtent([[-50, 0], [dimensions.width+50, dimensions.height]]) //limits how far graph can pan\n      .on(\"zoom\", e => {\n        const zoomState = e.transform; //returns zoom transformations as an object\n        setCurrentZoomState(zoomState);\n      });\n\n    //regular clicking\n    svg.on(\"click\", (e) => {\n      if (toggle===\"addInstant\") {\n        const x = generateScales(scales[activeScale]).xInverse(e.layerX);\n        const y = yScaleInverse(e.layerY);\n        setInflectTarget({x: x, y: y});\n        setToggle(\"NewInstantForm\");\n      }\n      setInfo(null)\n    });\n    svg.call(zoomBehavior);\n\n  }, [data, setData, zones, scales, toggle, activeLayer, activeData, dimensions, logic, currentZoomState, setInfo, radius, showLabel, syntacticOrder]);\n\n  return (\n    <div ref={wrapperRef} className=\"svgWrapper\">\n      <svg id=\"graphic\" ref={svgRef}>\n      </svg>\n    </div>\n  );\n};\n\n\nexport default Graphic;\n"]},"metadata":{},"sourceType":"module"}