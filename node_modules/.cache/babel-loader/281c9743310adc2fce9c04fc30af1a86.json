{"ast":null,"code":"var _jsxFileName = \"/Users/skye/Desktop/Portfolio/2021/chronologies/client/src/components/Graphic.js\",\n    _s = $RefreshSig$();\n\nimport React, { useState, useEffect, useRef } from 'react';\nimport { select, scaleLinear, scaleOrdinal, axisBottom, linkHorizontal, format, drag, zoom, min, max, symbol, symbols } from \"d3\";\nimport useResizeObserver from \"./useResizeObserver\"; // import generateLinks from \"./generateLinks\";\n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nfunction Graphic({\n  links,\n  data,\n  setData,\n  activeLayer,\n  intervals,\n  setIntervals,\n  radius,\n  info,\n  setInfo,\n  setInflectTarget,\n  showLabel,\n  toggle,\n  scales,\n  setScales\n}) {\n  _s();\n\n  //all data is passed down from and synced to App.js\n  const activeData = activeLayer ? data.filter(d => d.layer === activeLayer) : data; //is logical operators active?\n\n  const logic = isNaN(data[0].x); //Todo\n  //initialize reference object to pass to svg in React Dom\n\n  const svgRef = useRef(); //svg wrapped in div bc otherwise resize observer callback won't work\n\n  const wrapperRef = useRef();\n  const dimensions = useResizeObserver(wrapperRef);\n  const [currentZoomState, setCurrentZoomState] = useState(); // //initialize links between nodes\n  // const links = linkss;\n  //all d3 shennanigans goes in this hook. called initially and on every data change\n\n  useEffect(() => {\n    const svg = select(svgRef.current); //\"svg\" is the current version of svgRef data\n    //prevents crashing when useResizeObserver returns null before svg is rendered\n\n    if (!dimensions) return; //removes svgs added using append()\n\n    svg.selectAll(\".remove\").remove(); //initialize inflections for .selectAll\n    //add cancelled class\n    //---scales---//\n    //if time matches logical operator keyword, translate into index values, then map\n\n    const logicScale = scaleOrdinal([\"before\", \"now\", \"after\"], [-1, 0, 1]).unknown(0);\n    const breakpoint = 5;\n    const xMin = min(data.map(({\n      x\n    }) => logic ? logicScale(x) : x));\n    const xMax = max(data.map(({\n      x\n    }) => logic ? logicScale(x) : x));\n    const yMin = min(data.map(({\n      y\n    }) => y));\n    const yMax = max(data.map(({\n      y\n    }) => y));\n    const rangeX = xMax - xMin; //0 is minX, 1 is maxX (reference findMinMax)\n\n    const rangeY = yMax - yMin; //TODO: scaleTime()\n    //for multiple scales, generate a new scale for each x/y min - x/y max\n\n    /*\n    - Allow users to specify scale. x&y min max and units\n    - for each scale, generateScale()\n     */\n\n    function generateScales(currentScale) {\n      const x = scaleLinear().domain([currentScale.min, currentScale.max]) //scaleLinear takes domain (data values) & maps onto range (screen pixel values)\n      .range([0, dimensions.width]);\n      const y = scaleLinear() //if difference in y vaules greater than 5, resize to min and max\n      .domain(rangeY > breakpoint ? [yMin, yMax] : [yMin - breakpoint, yMax + breakpoint]).range([0, dimensions.height]);\n      const xInverse = scaleLinear().domain([-dimensions.width, dimensions.width]).range([-(currentScale.max - currentScale.min), currentScale.max - currentScale.min]); //maxRangeX-minRangeX gives section of x values displayed onscreen\n\n      const yInverse = scaleLinear().domain([-dimensions.height, dimensions.height]).range(rangeY > breakpoint ? [-rangeY, rangeY] : [-breakpoint * 5, breakpoint * 5]);\n      return {\n        x,\n        y,\n        xInverse,\n        yInverse\n      };\n    } //scales values to screen pixels\n\n    /*\n    {\n      biggie: {\n        ...\n        scale: generateScale()\n      }\n      ...\n    }\n    */\n    // const xScales = () => {\n    //   Object.keys(scales).forEach(key => { //for every scale in scales data, generate an xScale\n    //     // const thisScale = scales[key];\n    //     scales[key] = {...scales[key], scale:generateScales(scales[key]).x}\n    //   });\n    //   return scales;\n    // }\n\n\n    const xScales = Object.keys(scales).map(key => {\n      //for every scale in scales data, generate an xScale\n      const thisScale = scales[key];\n      return {\n        name: key,\n        scale: generateScales(thisScale).x,\n        yPos: thisScale.yPos,\n        units: thisScale.units\n      };\n    });\n    /*\n      xScales(generateScales(scaleLinear(scale)))\n      - take xScale and rescale according to transformations (newXScale)\n      - update each array entry's domain with that of newXScale\n    */\n    //if there is a zoom transform, override each xScales.scale with adjusted scale\n\n    if (currentZoomState) {\n      xScales.forEach((thisScale, i) => {\n        const newXScale = currentZoomState.rescaleX(thisScale.scale); //zoom state comes w methods for transformations\n\n        xScales[i].scale = newXScale; //sets domain to newXScale domain\n      });\n    }\n\n    ; // const xScale = scaleLinear()\n    //   .domain([xMin, xMax]) //scaleLinear takes domain (data values) & maps onto range (screen pixel values)\n    //   .range([0, dimensions.width]);\n\n    const yScale = scaleLinear() //if difference in y vaules greater than 5, resize to min and max\n    .domain(rangeY > breakpoint ? [yMin, yMax] : [yMin - breakpoint, yMax + breakpoint]).range([0, dimensions.height]); //inverse scales for drag behavior\n    // const xScaleInverse = scaleLinear()\n    //   .domain([-dimensions.width, dimensions.width])\n    //   .range([-rangeX, rangeX]); //maxRangeX-minRangeX gives section of x values displayed onscreen\n\n    const yScaleInverse = scaleLinear().domain([-dimensions.height, dimensions.height]).range(rangeY > breakpoint ? [-rangeY, rangeY] : [-breakpoint * 5, breakpoint * 5]); //---draw intervals---//\n\n    if (intervals.length) {\n      svg.selectAll(\".intervals\").data(intervals).join(\"rect\").attr(\"class\", \"intervals\").attr(\"x\", n => generateScales(scales[n.scale]).x(n.start)) // .attr(\"y\", n => n.yStart ? yScale(n.yStart) : yScale(minMax[2]))\n      .attr(\"y\", n => n.yStart ? yScale(n.yStart) : 0) //todo\n      .attr(\"width\", n => generateScales(scales[n.scale]).x(n.end) - generateScales(scales[n.scale]).x(n.start)).attr(\"height\", n => {\n        if (n.yStart & n.yEnd) {\n          return yScale(n.yEnd) - yScale(n.yStart);\n        } else if (n.yStart) {\n          return yScale(yMax + 10) - yScale(n.yStart);\n        } else {\n          return yScale(yMax + 10); //todo\n          // return (yScale(minMax[3])-yScale(minMax[2]))\n        }\n      }).attr(\"opacity\", d => d.opacity ? d.opacity : 0.5).attr(\"fill\", d => d.color ? d.color : \"#999\").on(\"click\", (e, target) => {\n        //displays line properties when clicked\n        setInfo({\n          position: [e.x, e.y],\n          target: target,\n          type: \"interval\"\n        }); //todo: set info to null when clicking again\n\n        e.stopPropagation();\n      });\n    } //---draw bottom axis---//\n\n\n    xScales.forEach(thisScale => {\n      const xAxis = axisBottom(thisScale.scale).tickFormat(format(''));\n      svg.append(\"g\") //todo\n      .attr(\"class\", \"remove\").style(\"transform\", `translateY(${dimensions.height * thisScale.yPos}px)`).call(xAxis).raise().call(g => g.select(\".domain\") //removes solid black axis bar\n      .remove()).call(g => g.selectAll(\".tick line\") //styles individual ticks\n      .attr(\"stroke-opacity\", 0.5)).call(g => g.selectAll(\".tick text\").attr(\"y\", 10) //todo?\n      .attr(\"opacity\", 0.5));\n      svg.append(\"text\").text(thisScale.units).attr(\"class\", \"axisLabel smallTxt remove\").attr(\"x\", dimensions.width / 2).attr(\"y\", dimensions.height * (thisScale.yPos + .07)).attr(\"text-anchor\", \"middle\").attr(\"opacity\", 0.5);\n    }); // const xAxis = axisBottom(generateScales(scales.smalls).x)\n    //   // .tickSize(-dimensions.height) //tick extends to entire height of svg\n    //   .tickValues(logic ? [-1, 0, 1] : null)\n    //   .tickFormat(logic ? x => scaleOrdinal([-1, 0, 1], [\"before\", \"now\", \"after\"])(x) : format('')); //gets rid of , for 1000s groupings\n    // svg\n    //   .select(\".x-axis\") //selects and replaces .x-axis\n    //   .style(\"transform\", `translateY(${dimensions.height}px)`)\n    //   .call(xAxis)\n    //   .raise()\n    // .call(g => g.select(\".domain\") //removes solid black axis bar\n    //   .remove())\n    // .call(g => g.selectAll(\".tick line\") //styles individual ticks\n    //   .attr(\"stroke-opacity\", 0.5))\n    //   // .attr(\"stroke-dasharray\", \"2,2\"))\n    // .call(g => g.selectAll(\".tick text\")\n    //   .attr(\"y\", 10) //todo?\n    //   .attr(\"opacity\", 0.5));\n    //   // .attr(\"font-size\", fontSize*.8)); //replace class \"x-axis\" w xAxis\n    //\n    //--drag behavior--//\n\n    const dragged = drag() // .on(\"start\", e => {\n    //   select(this).attr(\"stroke\", \"black\");\n    // })\n    .on(\"drag\", e => {\n      //todo (round new position to .01)\n      const dx = generateScales(scales[e.subject.scale]).xInverse(e.dx);\n      const dy = Math.round(yScaleInverse(e.dy) * 100) / 100;\n      const newNodes = [...data]; //always make a copy when updating array\n      //find array element in data with matching ID and set new x y coordinates\n\n      newNodes.find(n => n.id === e.subject.id).x += dx;\n      newNodes.find(n => n.id === e.subject.id).y += dy;\n      setData(newNodes);\n    }); //---draw links---//\n\n    const linker = linkHorizontal().source(link => link.source).target(link => link.target) // .x(n => generateScales(scales[n.scale]).x(logic ? logicScale(n.x) : n.x))\n    .x(d => xScales.find(n => n.name === d.scale).scale(d.x)).y(d => yScale(d.y));\n    svg.selectAll(\".link\").data(links).join(\"path\").raise().attr(\"class\", \"link pointer\").attr(\"d\", linker).attr(\"fill\", \"none\").attr(\"stroke\", n => n.color ? n.color : \"black\").attr(\"stroke-width\", n => n.width ? n.width : radius / 3).attr(\"stroke-opacity\", n => n.opacity ? n.opacity : 1).attr(\"stroke-dasharray\", n => n.dashed ? n.dashed : null).on(\"click\", (e, target) => {\n      console.log(target);\n\n      if (toggle === \"causality\") {//must select at least 2 temporal objects\n      } else if (toggle === \"foreshadowing\") {\n        if (!target.target) {//if target is an endpoint, indeterminate end\n        } else {//otherwise, change mouse to no symbol\n          } //option to adjust gradient eventually\n\n      } else if (toggle === \"certainty\" || toggle === \"importance\") {\n        console.log(target); // setInflectTarget(target);\n      } else {\n        setInfo({\n          position: [e.x, e.y],\n          target: target,\n          type: \"link\"\n        }); //displays line properties when clicked\n      }\n\n      e.stopPropagation();\n    }); //---draw points---//\n\n    svg.selectAll(\".node\").data(activeData.filter(d => !d.foreshadowing && !d.cancelled)).join(\"circle\").raise().attr(\"class\", \"node pointer\").attr(\"r\", n => n.radius ? n.radius : radius) //todo for accessibility\n    .attr(\"fill\", d => d.color ? d.color : \"black\") //if it has a color other than black, use that\n    .attr(\"opacity\", d => d.opacity ? d.opacity : 1) // .attr(\"cx\", d => generateScales(scales[d.scale]).x(logic ? logicScale(d.x) : d.x))\n    .attr(\"cx\", d => xScales.find(n => n.name === d.scale).scale(d.x)) //todo\n    .attr(\"cy\", d => yScale(d.y)).call(dragged).on(\"click\", (e, target) => {\n      if (toggle === \"cancelled\") {\n        const newNodes = [...data];\n        const node = newNodes.find(n => n.id === target.id);\n        node.cancelled = true;\n        setData(newNodes);\n      } else if (toggle === \"causality\") {//must select at least 2 temporal objects\n      } else if (toggle === \"foreshadowing\") {\n        //todo: adjust gradient\n        if (!target.target) {\n          //if target is an endpoint, indeterminate end\n          const newNodes = [...data];\n          const node = newNodes.find(n => n.id === target.id);\n          node.foreshadowing = true;\n          setData(newNodes);\n        } else {\n          //otherwise, change mouse to no symbol\n          console.log(\"forbidden\");\n        }\n      } else if (toggle === \"certainty\" || toggle === \"importance\") {\n        setInflectTarget(target);\n      } else {\n        setInfo({\n          position: [e.x, e.y],\n          target: target\n        }); //displays node properties when clicked\n      }\n\n      e.stopPropagation(); //stops deselect when bg is clicked\n    }); //---draw inflections---//\n    //--draw connetion inflection--//\n    //circle around point\n\n    svg.selectAll(\".connections\").data(activeData.filter(d => d.connections)).join(\"circle\").raise().attr(\"class\", \"connections pointer\").attr(\"r\", n => n.radius ? n.radius * 1.5 : radius * 2) //todo for accessibility\n    .attr(\"fill\", \"none\").attr(\"stroke\", \"black\").attr(\"stroke-dasharray\", \"3\") // .attr(\"opacity\", d => d.opacity ? d.opacity : 1)\n    .attr(\"cx\", d => xScales.find(n => n.name === d.scale).scale(d.x)) //todo\n    .attr(\"cy\", d => yScale(d.y)); //link connecting circles\n\n    const ctLinker = linkHorizontal().source(node => data.find(x => x.id === node.id)).target(node => data.find(x => x.id === node.connections[0])).x(d => xScales.find(n => n.name === d.scale).scale(d.x)).y(d => yScale(d.y));\n    svg.selectAll(\".connectionLinks\").data(activeData.filter(n => n.connections && !n.connections[1])).join(\"path\").raise().attr(\"class\", \"connectionLinks pointer\").attr(\"d\", ctLinker).attr(\"fill\", \"none\").attr(\"stroke\", \"black\") // .attr(\"stroke\", n => n.color? n.color : \"black\")\n    // .attr(\"stroke-opacity\", n => n.opacity ? n.opacity : 1)\n    .attr(\"stroke-dasharray\", \"3\"); //initialize custom symbols\n\n    const cancelledSymbol = {\n      draw: (context, size) => {\n        let s = Math.sqrt(size) / 2;\n        context.moveTo(s, 0);\n        context.lineTo(s * 2, s);\n        context.lineTo(s, s * 2);\n        context.lineTo(0, s);\n        context.lineTo(-s, s * 2);\n        context.lineTo(-s * 2, s);\n        context.lineTo(-s, 0);\n        context.lineTo(-s * 2, -s);\n        context.lineTo(-s, -s * 2);\n        context.lineTo(0, -s);\n        context.lineTo(s, -s * 2);\n        context.lineTo(s * 2, -s);\n        context.closePath();\n      }\n    }; //foreshadowing symbol\n\n    const fsSymbol = {\n      draw: (context, size) => {\n        let s = size;\n        context.moveTo(0, 0);\n        context.lineTo(s * 2, s / 2);\n        context.lineTo(s * 2, -s / 2);\n        context.closePath();\n      }\n    }; //foreshadowing gradient\n\n    var fsg = svg.append(\"defs\").append(\"linearGradient\").attr(\"id\", \"fsgradient\") //id of the gradient\n    .attr(\"x1\", \"0%\").attr(\"x2\", \"100%\") //since its a horizontal linear gradient\n    .attr(\"y1\", \"0%\").attr(\"y2\", \"0%\");\n    fsg.append(\"stop\").attr(\"offset\", \"0%\").style(\"stop-color\", \"black\") //start in black. TODO\n    .style(\"stop-opacity\", 1);\n    fsg.append(\"stop\").attr(\"offset\", \"100%\").style(\"stop-color\", \"black\") //end in transparent\n    .style(\"stop-opacity\", 0); //---draw symbols---//\n    //todo: doesn't work when cancelled is true from the start\n\n    svg.selectAll(\".cancelled\").data(activeData.filter(d => d.cancelled)).join(\"path\").raise().attr(\"class\", \"cancelled pointer\").attr(\"d\", symbol(cancelledSymbol, radius * radius * 5)).attr(\"fill\", d => d.color ? d.color : \"black\") //if it has a color other than black, use that\n    .attr(\"transform\", d => `translate(${xScales.find(n => n.name === d.scale).scale(d.x)}, ${yScale(d.y)})`).on(\"click\", (e, target) => {\n      if (toggle === \"cancelled\") {\n        const newNodes = [...data];\n        const node = newNodes.find(n => n.id === target.id);\n        delete node.cancelled;\n        setData(newNodes);\n      } else {\n        setInfo({\n          position: [e.x, e.y],\n          target: target\n        }); //displays node properties when clicked\n      }\n\n      e.stopPropagation();\n    }); //---draw foreshadowing---//\n\n    svg.selectAll(\".foreshadowing\").data(activeData.filter(d => d.foreshadowing)).join(\"path\").raise().attr(\"class\", \"foreshadowing pointer\").attr(\"d\", symbol(fsSymbol, radius * radius * 5)).style(\"fill\", \"url(#fsgradient)\").attr(\"transform\", d => `translate(${xScales.find(n => n.name === d.scale).scale(d.x)}, ${yScale(d.y)})`).on(\"click\", (e, target) => {\n      if (toggle === \"foreshadowing\") {\n        const newNodes = [...data];\n        const node = newNodes.find(n => n.id === target.id);\n        delete node.foreshadowing;\n        setData(newNodes);\n      } else {\n        setInfo({\n          position: [e.x, e.y],\n          target: target\n        }); //displays node properties when clicked\n      }\n\n      e.stopPropagation();\n    }); //---draw labels---//\n\n    svg.selectAll(\".label\").data(activeData).join(\"text\").raise().attr(\"class\", \"label\").text(node => showLabel ? node.name : node.id).attr(\"x\", d => xScales.find(n => n.name === d.scale).scale(d.x)).attr(\"y\", d => yScale(d.y + (rangeY > breakpoint ? rangeY * .06 : breakpoint / 5))) //vertical offset. see scales\n    .attr(\"text-anchor\", \"middle\"); // .attr(\"font-size\", fontSize);\n    //---zoom---//\n\n    const zoomBehavior = zoom().scaleExtent([0.25, 5]) //can zoom 2x smaller and 5x bigger\n    .translateExtent([[-100, 0], [dimensions.width + 100, dimensions.height]]) //limits how far graph can pan\n    .on(\"zoom\", e => {\n      const zoomState = e.transform; //returns zoom transformations as an object\n\n      setCurrentZoomState(zoomState);\n    });\n    svg.on(\"click\", () => setInfo(null));\n    svg.call(zoomBehavior);\n  }, [data, setData, intervals, scales, activeLayer, activeData, dimensions, links, logic, currentZoomState, setInfo, radius, showLabel]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: wrapperRef,\n    className: \"svgWrapper\",\n    children: /*#__PURE__*/_jsxDEV(\"svg\", {\n      id: \"graphic\",\n      ref: svgRef\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 487,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 486,\n    columnNumber: 5\n  }, this);\n}\n\n_s(Graphic, \"/KiWkGO4xuCDaFbcDOaAf23vnZg=\", false, function () {\n  return [useResizeObserver];\n});\n\n_c = Graphic;\n;\nexport default Graphic;\n\nvar _c;\n\n$RefreshReg$(_c, \"Graphic\");","map":{"version":3,"sources":["/Users/skye/Desktop/Portfolio/2021/chronologies/client/src/components/Graphic.js"],"names":["React","useState","useEffect","useRef","select","scaleLinear","scaleOrdinal","axisBottom","linkHorizontal","format","drag","zoom","min","max","symbol","symbols","useResizeObserver","Graphic","links","data","setData","activeLayer","intervals","setIntervals","radius","info","setInfo","setInflectTarget","showLabel","toggle","scales","setScales","activeData","filter","d","layer","logic","isNaN","x","svgRef","wrapperRef","dimensions","currentZoomState","setCurrentZoomState","svg","current","selectAll","remove","logicScale","unknown","breakpoint","xMin","map","xMax","yMin","y","yMax","rangeX","rangeY","generateScales","currentScale","domain","range","width","height","xInverse","yInverse","xScales","Object","keys","key","thisScale","name","scale","yPos","units","forEach","i","newXScale","rescaleX","yScale","yScaleInverse","length","join","attr","n","start","yStart","end","yEnd","opacity","color","on","e","target","position","type","stopPropagation","xAxis","tickFormat","append","style","call","raise","g","text","dragged","dx","subject","dy","Math","round","newNodes","find","id","linker","source","link","dashed","console","log","foreshadowing","cancelled","node","connections","ctLinker","cancelledSymbol","draw","context","size","s","sqrt","moveTo","lineTo","closePath","fsSymbol","fsg","zoomBehavior","scaleExtent","translateExtent","zoomState","transform"],"mappings":"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","sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\nimport { select, scaleLinear, scaleOrdinal, axisBottom, linkHorizontal, format, drag, zoom, min, max, symbol, symbols } from \"d3\";\nimport useResizeObserver from \"./useResizeObserver\";\n// import generateLinks from \"./generateLinks\";\n\nfunction Graphic({links, data, setData, activeLayer, intervals, setIntervals, radius, info, setInfo, setInflectTarget, showLabel, toggle, scales, setScales}) {\n\n  //all data is passed down from and synced to App.js\n  const activeData = activeLayer ? data.filter(d => d.layer === activeLayer) : data;\n\n  //is logical operators active?\n  const logic = isNaN(data[0].x); //Todo\n\n  //initialize reference object to pass to svg in React Dom\n  const svgRef = useRef();\n  //svg wrapped in div bc otherwise resize observer callback won't work\n  const wrapperRef = useRef();\n  const dimensions = useResizeObserver(wrapperRef);\n  const [currentZoomState, setCurrentZoomState] = useState();\n\n  // //initialize links between nodes\n  // const links = linkss;\n\n  //all d3 shennanigans goes in this hook. called initially and on every data change\n  useEffect(() => {\n    const svg = select(svgRef.current); //\"svg\" is the current version of svgRef data\n    //prevents crashing when useResizeObserver returns null before svg is rendered\n    if (!dimensions) return;\n    //removes svgs added using append()\n    svg\n      .selectAll(\".remove\")\n      .remove();\n\n    //initialize inflections for .selectAll\n    //add cancelled class\n\n    //---scales---//\n\n    //if time matches logical operator keyword, translate into index values, then map\n    const logicScale = scaleOrdinal([\"before\", \"now\", \"after\"], [-1, 0, 1]).unknown(0);\n\n    const breakpoint = 5;\n\n\n    const xMin = min(data.map(({x}) => logic ? logicScale(x) : x));\n    const xMax = max(data.map(({x}) => logic ? logicScale(x) : x));\n    const yMin = min(data.map(({y}) => y));\n    const yMax = max(data.map(({y}) => y));\n    const rangeX = xMax-xMin; //0 is minX, 1 is maxX (reference findMinMax)\n    const rangeY = yMax-yMin;\n\n\n    //TODO: scaleTime()\n\n    //for multiple scales, generate a new scale for each x/y min - x/y max\n    /*\n    - Allow users to specify scale. x&y min max and units\n    - for each scale, generateScale()\n\n    */\n\n    function generateScales(currentScale) {\n\n      const x = scaleLinear()\n        .domain([currentScale.min, currentScale.max]) //scaleLinear takes domain (data values) & maps onto range (screen pixel values)\n        .range([0, dimensions.width])\n      const y = scaleLinear()\n        //if difference in y vaules greater than 5, resize to min and max\n        .domain((rangeY>breakpoint) ? [yMin, yMax] : [yMin-breakpoint, yMax+breakpoint])\n        .range([0, dimensions.height])\n      const xInverse = scaleLinear()\n        .domain([-dimensions.width, dimensions.width])\n        .range([-(currentScale.max-currentScale.min), (currentScale.max-currentScale.min)]) //maxRangeX-minRangeX gives section of x values displayed onscreen\n      const yInverse = scaleLinear()\n        .domain([-dimensions.height, dimensions.height])\n        .range((rangeY>breakpoint) ? [-rangeY, rangeY] : [-breakpoint*5, breakpoint*5])\n\n\n      return {\n        x, y, xInverse, yInverse\n      };\n    }\n\n    //scales values to screen pixels\n    /*\n    {\n      biggie: {\n        ...\n        scale: generateScale()\n      }\n      ...\n    }\n    */\n    // const xScales = () => {\n    //   Object.keys(scales).forEach(key => { //for every scale in scales data, generate an xScale\n    //     // const thisScale = scales[key];\n    //     scales[key] = {...scales[key], scale:generateScales(scales[key]).x}\n    //   });\n    //   return scales;\n    // }\n\n\n\n    const xScales = Object.keys(scales).map(key => { //for every scale in scales data, generate an xScale\n      const thisScale = scales[key];\n      return ({\n        name: key,\n        scale: generateScales(thisScale).x,\n        yPos: thisScale.yPos,\n        units: thisScale.units\n      })\n    });\n\n    /*\n      xScales(generateScales(scaleLinear(scale)))\n      - take xScale and rescale according to transformations (newXScale)\n      - update each array entry's domain with that of newXScale\n    */\n    //if there is a zoom transform, override each xScales.scale with adjusted scale\n    if (currentZoomState) {\n      xScales.forEach((thisScale, i) => {\n        const newXScale = currentZoomState.rescaleX(thisScale.scale); //zoom state comes w methods for transformations\n        xScales[i].scale = newXScale; //sets domain to newXScale domain\n\n      });\n\n\n    };\n    // const xScale = scaleLinear()\n    //   .domain([xMin, xMax]) //scaleLinear takes domain (data values) & maps onto range (screen pixel values)\n    //   .range([0, dimensions.width]);\n    const yScale = scaleLinear()\n      //if difference in y vaules greater than 5, resize to min and max\n      .domain((rangeY>breakpoint) ? [yMin, yMax] : [yMin-breakpoint, yMax+breakpoint])\n      .range([0, dimensions.height]);\n    //inverse scales for drag behavior\n    // const xScaleInverse = scaleLinear()\n    //   .domain([-dimensions.width, dimensions.width])\n    //   .range([-rangeX, rangeX]); //maxRangeX-minRangeX gives section of x values displayed onscreen\n    const yScaleInverse = scaleLinear()\n      .domain([-dimensions.height, dimensions.height])\n      .range((rangeY>breakpoint) ? [-rangeY, rangeY] : [-breakpoint*5, breakpoint*5]);\n\n\n\n\n\n    //---draw intervals---//\n    if (intervals.length) {\n      svg\n      .selectAll(\".intervals\")\n      .data(intervals)\n      .join(\"rect\")\n      .attr(\"class\", \"intervals\")\n      .attr(\"x\", n => generateScales(scales[n.scale]).x(n.start))\n      // .attr(\"y\", n => n.yStart ? yScale(n.yStart) : yScale(minMax[2]))\n      .attr(\"y\", n => n.yStart ? yScale(n.yStart) : 0) //todo\n      .attr(\"width\", n => generateScales(scales[n.scale]).x(n.end)-generateScales(scales[n.scale]).x(n.start))\n      .attr(\"height\", n => {\n        if (n.yStart & n.yEnd) {\n          return (yScale(n.yEnd)-yScale(n.yStart))\n        } else if (n.yStart) {\n          return (yScale(yMax+10)-yScale(n.yStart))\n        } else {\n          return (yScale(yMax+10)) //todo\n          // return (yScale(minMax[3])-yScale(minMax[2]))\n        }})\n      .attr(\"opacity\", d => d.opacity ? d.opacity : 0.5)\n      .attr(\"fill\", d => d.color ? d.color : \"#999\")\n      .on(\"click\", (e, target) => {\n        //displays line properties when clicked\n        setInfo({position: [e.x, e.y], target: target, type: \"interval\"});  //todo: set info to null when clicking again\n        e.stopPropagation();\n      });\n    }\n\n    //---draw bottom axis---//\n\n    xScales.forEach(thisScale => {\n      const xAxis = axisBottom(thisScale.scale)\n      .tickFormat(format(''));\n\n      svg\n        .append(\"g\") //todo\n        .attr(\"class\", \"remove\")\n        .style(\"transform\", `translateY(${dimensions.height*thisScale.yPos}px)`)\n        .call(xAxis)\n        .raise()\n        .call(g => g.select(\".domain\") //removes solid black axis bar\n          .remove())\n        .call(g => g.selectAll(\".tick line\") //styles individual ticks\n          .attr(\"stroke-opacity\", 0.5))\n        .call(g => g.selectAll(\".tick text\")\n          .attr(\"y\", 10) //todo?\n          .attr(\"opacity\", 0.5));\n      svg\n        .append(\"text\")\n        .text(thisScale.units)\n        .attr(\"class\", \"axisLabel smallTxt remove\")\n        .attr(\"x\", dimensions.width/2)\n        .attr(\"y\", dimensions.height*(thisScale.yPos+.07))\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"opacity\", 0.5);\n      }\n    );\n\n\n    // const xAxis = axisBottom(generateScales(scales.smalls).x)\n    //   // .tickSize(-dimensions.height) //tick extends to entire height of svg\n    //   .tickValues(logic ? [-1, 0, 1] : null)\n    //   .tickFormat(logic ? x => scaleOrdinal([-1, 0, 1], [\"before\", \"now\", \"after\"])(x) : format('')); //gets rid of , for 1000s groupings\n\n    // svg\n    //   .select(\".x-axis\") //selects and replaces .x-axis\n    //   .style(\"transform\", `translateY(${dimensions.height}px)`)\n    //   .call(xAxis)\n    //   .raise()\n      // .call(g => g.select(\".domain\") //removes solid black axis bar\n      //   .remove())\n      // .call(g => g.selectAll(\".tick line\") //styles individual ticks\n      //   .attr(\"stroke-opacity\", 0.5))\n      //   // .attr(\"stroke-dasharray\", \"2,2\"))\n      // .call(g => g.selectAll(\".tick text\")\n      //   .attr(\"y\", 10) //todo?\n      //   .attr(\"opacity\", 0.5));\n      //   // .attr(\"font-size\", fontSize*.8)); //replace class \"x-axis\" w xAxis\n    //\n\n    //--drag behavior--//\n    const dragged = drag()\n      // .on(\"start\", e => {\n      //   select(this).attr(\"stroke\", \"black\");\n      // })\n      .on(\"drag\", e => {\n        //todo (round new position to .01)\n        const dx = generateScales(scales[e.subject.scale]).xInverse(e.dx);\n        const dy = Math.round(yScaleInverse(e.dy)*100)/100;\n        const newNodes = [...data]; //always make a copy when updating array\n        //find array element in data with matching ID and set new x y coordinates\n        newNodes.find(n => n.id === e.subject.id).x += dx;\n        newNodes.find(n => n.id === e.subject.id).y += dy;\n        setData(newNodes);\n      });\n\n    //---draw links---//\n    const linker = linkHorizontal()\n      .source(link => link.source)\n      .target(link => link.target)\n      // .x(n => generateScales(scales[n.scale]).x(logic ? logicScale(n.x) : n.x))\n      .x(d => xScales.find(n => n.name === d.scale).scale(d.x))\n      .y(d => yScale(d.y));\n\n    svg\n      .selectAll(\".link\")\n      .data(links)\n      .join(\"path\")\n      .raise()\n      .attr(\"class\", \"link pointer\")\n      .attr(\"d\", linker)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", n => n.color? n.color : \"black\")\n      .attr(\"stroke-width\", n => n.width ? n.width : radius/3)\n      .attr(\"stroke-opacity\", n => n.opacity ? n.opacity : 1)\n      .attr(\"stroke-dasharray\", n => n.dashed ? n.dashed : null)\n      .on(\"click\", (e, target) => {\n        console.log(target)\n        if (toggle===\"causality\") {\n          //must select at least 2 temporal objects\n\n        } else if (toggle===\"foreshadowing\") {\n          if (!target.target) { //if target is an endpoint, indeterminate end\n\n\n          } else { //otherwise, change mouse to no symbol\n\n          }\n          //option to adjust gradient eventually\n        } else if (toggle===\"certainty\" || toggle===\"importance\") {\n          console.log(target)\n          // setInflectTarget(target);\n        } else {\n          setInfo({position: [e.x, e.y], target: target, type: \"link\"}); //displays line properties when clicked\n        }\n        e.stopPropagation();\n      });\n\n\n    //---draw points---//\n    svg\n      .selectAll(\".node\")\n      .data(activeData.filter(d => !d.foreshadowing && !d.cancelled))\n      .join(\"circle\")\n      .raise()\n      .attr(\"class\", \"node pointer\")\n      .attr(\"r\", n => n.radius? n.radius : radius) //todo for accessibility\n      .attr(\"fill\", d => d.color ? d.color : \"black\") //if it has a color other than black, use that\n      .attr(\"opacity\", d => d.opacity ? d.opacity : 1)\n      // .attr(\"cx\", d => generateScales(scales[d.scale]).x(logic ? logicScale(d.x) : d.x))\n      .attr(\"cx\", d => xScales.find(n => n.name === d.scale).scale(d.x)) //todo\n      .attr(\"cy\", d => yScale(d.y))\n      .call(dragged)\n      .on(\"click\", (e, target) => {\n        if (toggle===\"cancelled\") {\n          const newNodes = [...data];\n          const node = newNodes.find(n => n.id === target.id);\n          node.cancelled = true;\n          setData(newNodes);\n        } else if (toggle===\"causality\") {\n          //must select at least 2 temporal objects\n\n        } else if (toggle===\"foreshadowing\") { //todo: adjust gradient\n          if (!target.target) { //if target is an endpoint, indeterminate end\n            const newNodes = [...data];\n            const node = newNodes.find(n => n.id === target.id);\n            node.foreshadowing = true;\n            setData(newNodes);\n          } else { //otherwise, change mouse to no symbol\n            console.log(\"forbidden\");\n          }\n        } else if (toggle===\"certainty\" || toggle===\"importance\"){\n          setInflectTarget(target);\n        } else {\n          setInfo({position: [e.x, e.y], target: target}); //displays node properties when clicked\n        }\n        e.stopPropagation(); //stops deselect when bg is clicked\n      });\n\n    //---draw inflections---//\n\n    //--draw connetion inflection--//\n    //circle around point\n    svg\n      .selectAll(\".connections\")\n      .data(activeData.filter(d => d.connections))\n      .join(\"circle\")\n      .raise()\n      .attr(\"class\", \"connections pointer\")\n      .attr(\"r\", n => n.radius? n.radius*1.5 : radius*2) //todo for accessibility\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", \"black\")\n      .attr(\"stroke-dasharray\", \"3\")\n      // .attr(\"opacity\", d => d.opacity ? d.opacity : 1)\n      .attr(\"cx\", d => xScales.find(n => n.name === d.scale).scale(d.x)) //todo\n      .attr(\"cy\", d => yScale(d.y));\n\n    //link connecting circles\n    const ctLinker = linkHorizontal()\n      .source(node => data.find(x => x.id === node.id))\n      .target(node => data.find(x => x.id === node.connections[0]))\n      .x(d => xScales.find(n => n.name === d.scale).scale(d.x))\n      .y(d => yScale(d.y));\n    svg\n      .selectAll(\".connectionLinks\")\n      .data(activeData.filter(n => n.connections && !n.connections[1]))\n      .join(\"path\")\n      .raise()\n      .attr(\"class\", \"connectionLinks pointer\")\n      .attr(\"d\", ctLinker)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", \"black\")\n      // .attr(\"stroke\", n => n.color? n.color : \"black\")\n      // .attr(\"stroke-opacity\", n => n.opacity ? n.opacity : 1)\n      .attr(\"stroke-dasharray\", \"3\")\n\n    //initialize custom symbols\n    const cancelledSymbol = {\n      draw: (context, size) => {\n        let s = Math.sqrt(size)/2;\n            context.moveTo(s,0);\n            context.lineTo(s*2,s);\n            context.lineTo(s,s*2);\n            context.lineTo(0,s);\n            context.lineTo(-s,s*2);\n            context.lineTo(-s*2,s);\n            context.lineTo(-s,0);\n            context.lineTo(-s*2,-s);\n            context.lineTo(-s,-s*2);\n            context.lineTo(0,-s);\n            context.lineTo(s,-s*2);\n            context.lineTo(s*2,-s);\n            context.closePath();\n      }\n    };\n    //foreshadowing symbol\n    const fsSymbol = {\n      draw: (context, size) => {\n        let s = size;\n            context.moveTo(0,0);\n            context.lineTo(s*2,s/2);\n            context.lineTo(s*2,-s/2);\n            context.closePath();\n      }\n    };\n    //foreshadowing gradient\n    var fsg = svg.append(\"defs\").append(\"linearGradient\")\n    .attr(\"id\", \"fsgradient\")//id of the gradient\n    .attr(\"x1\", \"0%\")\n    .attr(\"x2\", \"100%\") //since its a horizontal linear gradient\n    .attr(\"y1\", \"0%\")\n    .attr(\"y2\", \"0%\");\n\n    fsg.append(\"stop\")\n    .attr(\"offset\", \"0%\")\n    .style(\"stop-color\", \"black\")//start in black. TODO\n    .style(\"stop-opacity\", 1);\n\n    fsg.append(\"stop\")\n    .attr(\"offset\", \"100%\")\n    .style(\"stop-color\", \"black\")//end in transparent\n    .style(\"stop-opacity\", 0);\n\n    //---draw symbols---//\n    //todo: doesn't work when cancelled is true from the start\n    svg\n      .selectAll(\".cancelled\")\n      .data(activeData.filter(d => d.cancelled))\n      .join(\"path\")\n      .raise()\n      .attr(\"class\", \"cancelled pointer\")\n      .attr(\"d\", symbol(cancelledSymbol, radius*radius*5))\n      .attr(\"fill\", d => d.color ? d.color : \"black\") //if it has a color other than black, use that\n      .attr(\"transform\", d => `translate(${xScales.find(n => n.name === d.scale).scale(d.x)}, ${yScale(d.y)})`)\n      .on(\"click\", (e, target) => {\n        if (toggle===\"cancelled\") {\n          const newNodes = [...data];\n          const node = newNodes.find(n => n.id === target.id);\n          delete node.cancelled;\n          setData(newNodes);\n        } else {\n          setInfo({position: [e.x, e.y], target: target}); //displays node properties when clicked\n        }\n        e.stopPropagation();\n      });\n\n    //---draw foreshadowing---//\n    svg\n      .selectAll(\".foreshadowing\")\n      .data(activeData.filter(d => d.foreshadowing))\n      .join(\"path\")\n      .raise()\n      .attr(\"class\", \"foreshadowing pointer\")\n      .attr(\"d\", symbol(fsSymbol, radius*radius*5))\n      .style(\"fill\", \"url(#fsgradient)\")\n      .attr(\"transform\", d => `translate(${xScales.find(n => n.name === d.scale).scale(d.x)}, ${yScale(d.y)})`)\n      .on(\"click\", (e, target) => {\n        if (toggle===\"foreshadowing\") {\n          const newNodes = [...data];\n          const node = newNodes.find(n => n.id === target.id);\n          delete node.foreshadowing;\n          setData(newNodes);\n        } else {\n          setInfo({position: [e.x, e.y], target: target}); //displays node properties when clicked\n        }\n        e.stopPropagation();\n      });\n\n    //---draw labels---//\n    svg\n      .selectAll(\".label\")\n      .data(activeData)\n      .join(\"text\")\n      .raise()\n      .attr(\"class\", \"label\")\n      .text(node => showLabel ? node.name : node.id)\n      .attr(\"x\", d => xScales.find(n => n.name === d.scale).scale(d.x))\n      .attr(\"y\", d => yScale(d.y + (rangeY>breakpoint ? rangeY*.06 : breakpoint/5))) //vertical offset. see scales\n      .attr(\"text-anchor\", \"middle\");\n      // .attr(\"font-size\", fontSize);\n\n\n    //---zoom---//\n    const zoomBehavior = zoom()\n      .scaleExtent([0.25, 5]) //can zoom 2x smaller and 5x bigger\n      .translateExtent([[-100, 0], [dimensions.width+100, dimensions.height]]) //limits how far graph can pan\n      .on(\"zoom\", e => {\n        const zoomState = e.transform; //returns zoom transformations as an object\n        setCurrentZoomState(zoomState);\n      });\n\n    svg.on(\"click\", () => setInfo(null));\n    svg.call(zoomBehavior);\n\n  }, [data, setData, intervals, scales, activeLayer, activeData, dimensions, links, logic, currentZoomState, setInfo, radius, showLabel]);\n\n  return (\n    <div ref={wrapperRef} className=\"svgWrapper\">\n      <svg id=\"graphic\" ref={svgRef}>\n      </svg>\n    </div>\n  );\n};\n\n\nexport default Graphic;\n"]},"metadata":{},"sourceType":"module"}