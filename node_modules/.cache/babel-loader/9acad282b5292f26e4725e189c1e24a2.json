{"ast":null,"code":"import _objectSpread from\"/Users/skye/Desktop/Portfolio/chronovis/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _toConsumableArray from\"/Users/skye/Desktop/Portfolio/chronovis/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _createForOfIteratorHelper from\"/Users/skye/Desktop/Portfolio/chronovis/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _slicedToArray from\"/Users/skye/Desktop/Portfolio/chronovis/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import React,{useState,useEffect,useRef}from'react';import{select,scaleLinear,scaleOrdinal,axisBottom,axisLeft,linkHorizontal,format,drag,zoom,min,max,symbol,symbols}from\"d3\";import useResizeObserver from\"./useResizeObserver\";import generateIntervals from\"./generateIntervals\";import{jsx as _jsx}from\"react/jsx-runtime\";function Graphic(_ref){var data=_ref.data,setData=_ref.setData,updateSrc=_ref.updateSrc,activeLayer=_ref.activeLayer,zones=_ref.zones,setZones=_ref.setZones,radius=_ref.radius,info=_ref.info,setInfo=_ref.setInfo,setInflectTarget=_ref.setInflectTarget,showLabel=_ref.showLabel,toggle=_ref.toggle,setToggle=_ref.setToggle,scales=_ref.scales,setScales=_ref.setScales,syntacticOrder=_ref.syntacticOrder,setSyntacticOrder=_ref.setSyntacticOrder,activeScale=_ref.activeScale;//all data is passed down from and synced to App.js\nvar activeData=Object.entries(data);//convert json to array for faster processing\nvar activeZones=Object.entries(zones);//TODO: layers\n// const activeData = activeLayer ? Object.entries(data).filter(([k,v]) => v.layer === activeLayer) : arrayData;\n//convert scale object to array for faster processing\n//is logical operators active?\nvar logic=data.length?isNaN(data[0].x):null;//TODO: refine logical operators\n//initialize reference object to pass to svg in React Dom\nvar svgRef=useRef();//svg wrapped in div bc otherwise resize observer callback won't work\nvar wrapperRef=useRef();var dimensions=useResizeObserver(wrapperRef);var _useState=useState(),_useState2=_slicedToArray(_useState,2),currentZoomState=_useState2[0],setCurrentZoomState=_useState2[1];//hash map of y scales\nvar yScales={};//init scales\nuseEffect(function(){if(!dimensions)return;var yTicks=[];var _iterator=_createForOfIteratorHelper(activeData),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var v=_step.value;yTicks.push(activeData.y);}}catch(err){_iterator.e(err);}finally{_iterator.f();}Object.entries(scales.y).forEach(function(_ref2){var _ref3=_slicedToArray(_ref2,2),k=_ref3[0],v=_ref3[1];yScales[k]={scale:scaleLinear().domain([0,dimensions.height]).range([v.min,v.max]),drag:scaleLinear().domain([-dimensions.height,dimensions.height]).range([-(v.max-v.min),v.max-v.min]),ticks:_toConsumableArray(new Set(yTicks))};});},[dimensions,scales,currentZoomState]);//initialize intervals between instants\nvar intervals=generateIntervals(data);//TODO: write updateIntervals function\n//initialize variables\n/*\n  var xMin = min(Object.entries(data).map(([key, {x}]) => logic ? logicScale(x) : x));\n  var xMax = max(Object.entries(data).map(([key, {x}]) => logic ? logicScale(x) : x));\n  var yMin = min(Object.entries(data).map(([key, {y}]) => y));\n  var yMax = max(Object.entries(data).map(([key, {y}]) => y));\n  */ //all d3 shennanigans goes in this hook. called initially and on every data change\nuseEffect(function(){var svg=select(svgRef.current);//\"svg\" is the current version of svgRef data\n//prevents crashing when useResizeObserver returns null before svg is rendered\nif(!dimensions)return;//removes svgs added using append()\nsvg.selectAll(\".remove\").remove();//rounding for data inputted thru paintbox interface\nfunction round(value,range){var precision=Math.log10(range)<1?-Math.floor(Math.log10(range)-1):0;return Math.round(value*Math.pow(10,precision))/Math.pow(10,precision);}//---scales---//\n//if time matches logical operator keyword, translate into index values, then map\nvar logicScale=scaleOrdinal([\"before\",\"now\",\"after\"],[-1,0,1]).unknown(0);var breakpoint=5;var xMin=min(activeData.map(function(_ref4){var _ref5=_slicedToArray(_ref4,2),key=_ref5[0],x=_ref5[1].x;return logic?logicScale(x):x;}));var xMax=max(activeData.map(function(_ref6){var _ref7=_slicedToArray(_ref6,2),key=_ref7[0],x=_ref7[1].x;return logic?logicScale(x):x;}));// const yMin = min(Object.entries(data).map(([key, {y}]) => y));\n// const yMax = max(Object.entries(data).map(([key, {y}]) => y));\nvar yTicks=activeData.map(function(_ref8){var _ref9=_slicedToArray(_ref8,2),y=_ref9[1].y;return y;});var yMin=scales.y[activeScale[1]].min;var yMax=scales.y[activeScale[1]].max;var rangeX=xMax-xMin;//0 is minX, 1 is maxX (reference findMinMax)\nvar rangeY=yMax-yMin;/*\n    - Allow users to specify scale. x&y min max and units label\n    - for each scale, generateScale()\n    */ // function generateScales(currentScale) { //TODO: turn into dedicated scaleDrag\n//\n//   const xInverse = scaleLinear()\n//     .domain([0, dimensions.width])\n//     .range([currentScale.min, currentScale.max]) //maxRangeX-minRangeX gives section of x values displayed onscreen\n//   const xDrag = scaleLinear()\n//     .domain([-dimensions.width, dimensions.width])\n//     .range([-(currentScale.domain()[1]-currentScale.domain()[0]), (currentScale.domain()[1]-currentScale.domain()[0])]) //maxRangeX-minRangeX gives section of x values displayed onscreen\n//   const yInverse = scaleLinear()\n//     .domain([-dimensions.height, dimensions.height])\n//     .range((rangeY>breakpoint) ? [-rangeY, rangeY] : [-breakpoint*5, breakpoint*5])\n//\n//\n//   return {\n//     xInverse, xDrag, yInverse\n//   };\n// }\nvar xInverse=function xInverse(currentScale){return scaleLinear().domain([0,dimensions.width]).range([currentScale.min,currentScale.max]);};//maxRangeX-minRangeX gives section of x values displayed onscreen\nvar xDrag=function xDrag(currentScale){return scaleLinear().domain([-dimensions.width,dimensions.width]).range([-(currentScale.domain()[1]-currentScale.domain()[0]),currentScale.domain()[1]-currentScale.domain()[0]]);};//maxRangeX-minRangeX gives section of x values displayed onscreen\n// const yInverse = scaleLinear()\n//   .domain([-dimensions.height, dimensions.height])\n//   .range((rangeY>breakpoint) ? [-rangeY, rangeY] : [-breakpoint*5, breakpoint*5])\n//scales values to screen pixels\n/*\n    {\n      biggie: {\n        ...\n        scale: generateScale()\n      }\n      ...\n    }\n    */ /*\n    xScale =\n    {\n\n  }\n    */ //TODO: fromEntries & entries not compatible with some older browsers\nvar xScales=Object.fromEntries(//for every scale in scales data, generate an xScale\nObject.entries(scales.x).map(function(_ref10){var _ref11=_slicedToArray(_ref10,2),key=_ref11[0],thisScale=_ref11[1];return[key,{scale:scaleLinear()//scaleLinear takes domain (data values) & maps onto range (screen pixel values)\n.domain([thisScale.min,thisScale.max]).range([0,dimensions.width]),noBeginning:thisScale.min-10,noEnd:thisScale.max+10,hasSegments:thisScale.segments.length?true:false,hideLabel:thisScale.hideLabel,yPos:thisScale.yPos,label:\"\".concat(key,\" (\").concat(thisScale.units,\")\"),tickValues:thisScale.tickValues?thisScale.tickValues:null,scaleInverse:scaleLinear()//for NewInstantForm\n.domain([0,dimensions.width]).range([thisScale.min,thisScale.max])}];}));var xSegments=function xSegments(){var segments=[];Object.keys(scales.x).forEach(function(key,i){var thisScale=scales.x[key];// const segments = [];\nif(!thisScale.segments.length){return;}thisScale.segments.map(function(n){var min=n.min?n.min:thisScale.min;//if segment contains a min, set that as min. otherwise, set scale min as min.\nvar max=n.max?n.max:thisScale.max;// console.log(xScales[i].scale(min));\nsegments.push({scale:key,yPos:thisScale.yPos,proportion:(max-min)/(thisScale.max-thisScale.min),segment:scaleLinear().domain([min,max]).range([xScales[key].scale(min),xScales[key].scale(max)])});});});return segments;};/*\n      xScales(generateScales(scaleLinear(scale)))\n      - take xScale and rescale according to transformations (newXScale)\n      - update each array entry's domain with that of newXScale\n    */ //if there is a zoom transform, override each xScales.scale with adjusted scale\nif(currentZoomState){Object.entries(xScales).forEach(function(_ref12){var _ref13=_slicedToArray(_ref12,2),key=_ref13[0],thisScale=_ref13[1];var newXScale=currentZoomState.rescaleX(thisScale.scale);//zoom state comes w methods for transformations\nvar newMin=newXScale.domain()[0];var newMax=newXScale.domain()[1];//applies zoom transformations to scale + scaleInverse\nxScales[key].scale=newXScale;});};// const xScale = scaleLinear()\n//   .domain([xMin, xMax]) //scaleLinear takes domain (data values) & maps onto range (screen pixel values)\n//   .range([0, dimensions.width]);\nvar yScale=scaleLinear()//if difference in y vaules greater than 5, resize to min and max\n// .domain((rangeY>breakpoint) ? [yMin, yMax] : [yMin-breakpoint, yMax+breakpoint])\n.domain([yMin,yMax]).range([dimensions.height,0]);//inverse scales for drag behavior\n// const xScaleInverse = scaleLinear()\n//   .domain([-dimensions.width, dimensions.width])\n//   .range([-rangeX, rangeX]); //maxRangeX-minRangeX gives section of x values displayed onscreen\nvar yScaleInverse=scaleLinear().domain([0,dimensions.height]).range([yMin,yMax]);// .range((rangeY>breakpoint) ? [yMin, yMax] : [yMin-breakpoint, yMax+breakpoint]);\nvar yScaleInverseDrag=scaleLinear().domain([dimensions.height,-dimensions.height]).range([-rangeY,rangeY]);// .range((rangeY>breakpoint) ? [-rangeY, rangeY] : [-breakpoint*5, breakpoint*5]);\n//---draw zones---//\nif(activeZones.length){svg.selectAll(\".zones\").data(activeZones).join(\"rect\").attr(\"class\",\"zones\").attr(\"x\",function(_ref14){var _ref15=_slicedToArray(_ref14,2),v=_ref15[1];return xScales[v.scale[0]].scale(v.start);})// .attr(\"x\", n => generateScales(scales[n.scale]).x(n.start))\n.attr(\"y\",function(_ref16){var _ref17=_slicedToArray(_ref16,2),v=_ref17[1];return yScale(yMax);})// .attr(\"y\", ([, v]) => v.yStart ? yScale(v.yStart) : yMin-10) //TODO: if no yStart, minimum y value\n.attr(\"width\",function(_ref18){var _ref19=_slicedToArray(_ref18,2),v=_ref19[1];return xScales[v.scale[0]].scale(v.end)-xScales[v.scale[0]].scale(v.start);}).attr(\"height\",function(_ref20){var _ref21=_slicedToArray(_ref20,2),v=_ref21[1];return yScale(yMin);// if (v.yStart & v.yEnd) {\n//   return (yScale(v.yStart)-yScale(v.yEnd))\n// } else if (v.yStart) {\n//   return (yScale(v.yStart)-yScale(yMax-10))\n// } else {\n//   return (yScale(yMax-10)) //TODO: if no yStart, minimum y value\n//   // return (yScale(minMax[3])-yScale(minMax[2]))\n// }\n}).attr(\"opacity\",function(_ref22){var _ref23=_slicedToArray(_ref22,2),k=_ref23[0],v=_ref23[1];return v.opacity?v.opacity:0.5;}).attr(\"fill\",function(_ref24){var _ref25=_slicedToArray(_ref24,2),k=_ref25[0],v=_ref25[1];return v.color?v.color:\"#999\";}).attr(\"stroke\",\"black\")//TODO: stroke be different colors\n.attr(\"stroke-width\",function(_ref26){var _ref27=_slicedToArray(_ref26,2),k=_ref27[0],v=_ref27[1];return v.importance?v.importance*2:0;}).on(\"click\",function(e,target){if(toggle===\"certainty\"||toggle===\"importance\"){//pulls up inflection menu\nsetInflectTarget(target);}else{//displays zone properties when clicked\nsetInfo(null);//clear InfoBox\nsetInfo({position:[e.x,e.y],target:target,type:\"zone\"});//TODO: set info to null when clicking same zone again\n}e.stopPropagation();});}//---draw bottom axis---//\nxSegments().forEach(function(n){//TODO: push all the axis ticks() values into an array\n// [...new Set(segments)]\n//draw from there\nvar segment=axisBottom(n.segment)// .ticks(n.proportion<.33?5:null, \"f\");\n.ticks(null,\"f\").tickSize(-dimensions.height);//TODO\nsvg.append(\"g\").attr(\"class\",\"remove\").style(\"transform\",\"translateY(\".concat(dimensions.height*n.yPos,\"px)\")).call(segment).raise().call(function(g){return g.select(\".domain\")//removes solid black axis bar\n.remove();}).call(function(g){return g.selectAll(\".tick line\")//styles individual ticks\n.attr(\"stroke-opacity\",0.25);}).call(function(g){return g.selectAll(\".tick text\").attr(\"y\",10).attr(\"opacity\",function(d,i){//TODO: remove instead of setting opacity to 0\nif(n.proportion<.25&&i%3){//less than 1/4, label every 3 ticks\nreturn 0;}else if(n.proportion<.33&&i%2){//less than 1/3, label every other tick\nreturn 0;}else{return 0.5;}});});});Object.entries(xScales).forEach(function(_ref28){var _ref29=_slicedToArray(_ref28,2),key=_ref29[0],thisScale=_ref29[1];var xAxis=axisBottom(thisScale.scale).tickValues(thisScale.scale.ticks().concat(scales.x[key].min,scales.x[key].max))//pass in autogenerated tick values + min and max values\n.tickFormat(format('')).tickSize(-dimensions.height);// console.log(thisScale.scale.ticks())\nif(!thisScale.hasSegments){svg.append(\"g\").attr(\"class\",\"remove\").style(\"transform\",\"translateY(\".concat(dimensions.height*thisScale.yPos,\"px)\")).call(xAxis).raise().call(function(g){return g.select(\".domain\")//removes solid black axis bar\n.remove();}).call(function(g){return g.selectAll(\".tick line\")//styles individual ticks\n.attr(\"stroke-opacity\",0.25);}).call(function(g){return g.selectAll(\".tick text\").attr(\"y\",10)//TODO: dynamic tick text spacing for accessibility\n.attr(\"opacity\",0.5);});}if(!thisScale.hideUnits){svg.append(\"text\").text(thisScale.label).attr(\"class\",\"axisLabel smallTxt remove\").attr(\"x\",dimensions.width/2).attr(\"y\",dimensions.height*(thisScale.yPos+.07)).attr(\"text-anchor\",\"middle\").attr(\"opacity\",0.5);}});//--draw vertical axis--//\nvar yAxis=axisLeft(yScale).tickValues([].concat(_toConsumableArray(new Set(yTicks)),[scales.y[activeScale[1]].min,scales.y[activeScale[1]].max]))//reg mode\n.tickFormat(format(''));svg.append(\"g\").attr(\"class\",\"remove\")// .style(\"transform\", `translateY(${dimensions.height*thisScale.yPos}px)`)\n.call(yAxis).raise().call(function(g){return g.select(\".domain\")//removes solid black axis bar\n.remove();}).call(function(g){return g.selectAll(\".tick line\")//styles individual ticks\n.attr(\"stroke-opacity\",0.5);}).call(function(g){return g.selectAll(\".tick text\").attr(\"y\",10)//TODO: dynamic tick text spacing for accessibility\n.attr(\"opacity\",0.5);});if(!scales.y[activeScale[1]].hideLabels){svg.append(\"text\").text(\"\".concat(activeScale[1],\" (\").concat(scales.y[activeScale[1]].units,\")\")).attr(\"class\",\"axisLabel smallTxt remove\")// .attr(\"x\", dimensions.width/2)\n// .attr(\"y\", dimensions.height/2)\n.attr(\"text-anchor\",\"middle\").attr(\"transform\",\"translate(-30,\".concat(dimensions.height/2,\")rotate(-90)\")).attr(\"opacity\",0.5);}//--drag behavior--//\nvar dragged=drag()// .on(\"start\", e => {\n//   select(this).attr(\"stroke\", \"black\");\n// })\n.on(\"drag\",function(e){//TODO: extract precision function to round new pos\nvar dx=xDrag(xScales[e.subject[1].scale[0]].scale)(e.dx);// const dx = xScales.scaleInverse\nvar dy=yScaleInverseDrag(e.dy);var newInstants=_objectSpread({},data);//always make a copy when updating array\n//find array element in data with matching ID and set new x y coordinates\nnewInstants[e.subject[0]].x+=dx;newInstants[e.subject[0]].y+=dy;setData(newInstants);})//TODO: unify onEnd and onClick\n.on(\"end\",function(e){console.log(\"end\");});if(Object.entries(data).length){//---draw intervals---//\nvar intervaler=linkHorizontal().source(function(interval){return interval.source[1];}).target(function(interval){return interval.target[1];})// .x(n => generateScales(scales[n.scale]).x(logic ? logicScale(n.x) : n.x))\n.x(function(v){if(!isNaN(v.x)){return xScales[v.scale[0]].scale(v.x);}else if(v.x===\"noEnd\"){return xScales[v.scale[0]].noEnd;}else if(v.x===\"noBeginning\"){return xScales[v.scale[0]].noBeginning;}}).y(function(v){return yScale(v.y);});svg.selectAll(\".interval\").data(intervals).join(\"path\").raise().attr(\"class\",\"interval pointer\").attr(\"d\",intervaler).attr(\"fill\",\"none\").attr(\"stroke\",function(n){return n.color?n.color:\"black\";}).attr(\"stroke-width\",function(n){return n.width?n.width:radius;}).attr(\"stroke-opacity\",function(n){return n.opacity?n.opacity:1;}).attr(\"stroke-dasharray\",function(n){return n.dashed?n.dashed:null;}).on(\"click\",function(e,target){if(toggle===\"connection\"){var newOrder=_toConsumableArray(syntacticOrder);if(newOrder[2]===0){//set 2nd selection\nnewOrder[1]={x:xInverse(scales.x[activeScale[0]])(e.layerX),y:yScaleInverse(e.layerY),scale:activeScale};//scale TODO\nnewOrder[2]=1;}else{//set 1st selection\nnewOrder[0]={x:xInverse(scales.x[activeScale[0]])(e.layerX),y:yScaleInverse(e.layerY),scale:activeScale};newOrder[2]=0;}setSyntacticOrder(newOrder);}//else if (toggle===\"foreshadowing\") {\n//   if (!target.target) { //if target is an endpoint, indeterminate end\n//\n//\n//   } else { //otherwise, change mouse to no symbol\n//\n//   }\n//   //option to adjust gradient eventually\n// } else\nelse if(toggle===\"certainty\"||toggle===\"importance\"){setInflectTarget(target);}else{setInfo(null);//clear InfoBox\nsetInfo({position:[e.x,e.y],target:target,type:\"interval\"});//displays interval properties when clicked\n}e.stopPropagation();});//---draw instants---//\nsvg.selectAll(\".instant\")// .data(activeData.filter(d => !d.foreshadowing && !d.cancelled))\n.data(activeData).join(\"circle\").raise().attr(\"class\",\"instant pointer\").attr(\"r\",function(_ref30){var _ref31=_slicedToArray(_ref30,2),v=_ref31[1];return v.radius?v.radius:radius;})//TODO: custom radius accessibility\n.attr(\"fill\",function(_ref32){var _ref33=_slicedToArray(_ref32,2),v=_ref33[1];return v.color?v.color:\"black\";})//if it has a color other than black, use that\n.attr(\"opacity\",function(_ref34){var _ref35=_slicedToArray(_ref34,2),v=_ref35[1];return v.opacity?v.opacity:1;})// .attr(\"cx\", d => generateScales(scales[d.scale]).x(logic ? logicScale(d.x) : d.x))\n.attr(\"cx\",function(_ref36){var _ref37=_slicedToArray(_ref36,2),v=_ref37[1];if(!isNaN(v.x)){return xScales[v.scale[0]].scale(v.x);}else if(v.x===\"noBeginning\"){return xScales[v.scale[0]].noBeginning;}else if(v.x===\"noEnd\"){return xScales[v.scale[0]].noEnd;}})//scale x coordinate based on xScale defined in instant's scale property\n.attr(\"cy\",function(_ref38){var _ref39=_slicedToArray(_ref38,2),v=_ref39[1];return yScale(v.y);}).call(dragged).on(\"click\",function(e,target){switch(toggle){case\"cancelled\":var newData=_objectSpread({},data);newData[target[0]].cancelled=true;// console.log(newData[target[0]]);\nupdateSrc(newData);break;case\"connection\":var newOrder=_toConsumableArray(syntacticOrder);if(newOrder[2]===0){//set 2nd selection\nnewOrder[1]=target;newOrder[2]=1;}else{//set 1st selection\nnewOrder[0]=target;newOrder[2]=0;}setSyntacticOrder(newOrder);break;case\"foreshadowing\":if(!target.target){//if target is an endpoint, indeterminate end\nvar newInstants=_toConsumableArray(data);var instant=newInstants.find(function(n){return n.id===target.id;});instant.foreshadowing=true;setData(newInstants);}else{//otherwise, change mouse to no symbol\nconsole.log(\"forbidden\");}break;case\"certainty\":setInflectTarget(target);break;case\"importance\":setInflectTarget(target);break;default:setInfo(null);//clear InfoBox\nsetInfo({position:[e.x,e.y],target:target});//displays instant properties when clicked\n}// if (toggle===\"cancelled\") {\n//   const newInstants = [...data];\n//   const instant = newInstants.find(n => n.id === target.id);\n//   instant.cancelled = true;\n//   setData(newInstants);\n// } else if (){\n//\n// } else if (toggle===\"connection\") {\n//   const newOrder = [...syntacticOrder];\n//   if (newOrder[2]===0) { //set 2nd selection\n//     newOrder[1] = target;\n//     newOrder[2] = 1;\n//   } else { //set 1st selection\n//     newOrder[0] = target;\n//     newOrder[2] = 0;\n//   }\n//   setSyntacticOrder(newOrder);\n// } else if (toggle===\"foreshadowing\") { //todo: adjust gradient\n//   if (!target.target) { //if target is an endpoint, indeterminate end\n//     const newInstants = [...data];\n//     const instant = newInstants.find(n => n.id === target.id);\n//     instant.foreshadowing = true;\n//     setData(newInstants);\n//   } else { //otherwise, change mouse to no symbol\n//     console.log(\"forbidden\");\n//   }\n// } else if (toggle===\"certainty\" || toggle===\"importance\"){\n//   setInflectTarget(target);\n// } else {\n//   setInfo({position: [e.x, e.y], target: target}); //displays instant properties when clicked\n// }\ne.stopPropagation();//stops deselect when bg is clicked\n});/*//---draw inflections---//\n\n      //--draw connetion inflection--//\n      //circle around instant\n      svg\n        .selectAll(\".connections\")\n        .data(activeData.filter(d => d.connections))\n        .join(\"circle\")\n        .raise()\n        .attr(\"class\", \"connections pointer\")\n        .attr(\"r\", n => n.radius? n.radius*1.5 : radius*2) //TODO: custom radius accessibility\n        .attr(\"fill\", \"none\")\n        .attr(\"stroke\", \"black\")\n        .attr(\"stroke-dasharray\", \"3\")\n        // .attr(\"opacity\", d => d.opacity ? d.opacity : 1)\n        .attr(\"cx\", d => xScales[d.scale].scale(d.x)) //scale x coordinate based on xScale defined in instant's scale property\n        .attr(\"cy\", d => yScale(d.y));\n\n      //link connecting circles\n      const ctLinker = linkHorizontal()\n        .source(instant => data.find(x => x.id === instant.id))\n        .target(instant => typeof(instant.connections[0])===\"object\" ? instant.connections[0] : data.find(x => x.id === instant.connections[0]))\n        // .target(() => {\n        //   //layerX, layerY\n        //   const y = yScaleInverse(499);\n        //   const x = xScales.find(n => n.text === \"biggie\").scaleInverse(778)\n        //   return {x: x, y: y}\n        // })\n        // .target(instant => data.find(x => x.id === instant.connections[0]))\n        .x(d => d.scale ? xScales[d.scale].scale(d.x) : d.x)\n        .y(d => d.scale ? yScale(d.y) : d.y);\n      svg\n        .selectAll(\".connectionLinks\")\n        .data(activeData.filter(n => n.connections && !n.connections[1])) //link starts from 1st one\n        .join(\"path\")\n        .raise()\n        .attr(\"class\", \"connectionLinks pointer\")\n        .attr(\"d\", ctLinker)\n        .attr(\"fill\", \"none\")\n        .attr(\"stroke\", \"black\")\n        // .attr(\"stroke\", n => n.color? n.color : \"black\")\n        // .attr(\"stroke-opacity\", n => n.opacity ? n.opacity : 1)\n        .attr(\"stroke-dasharray\", \"3\")\n*/ //initialize custom symbols\nvar cancelledSymbol={draw:function draw(context,size){var s=Math.sqrt(size)/2;context.moveTo(s,0);context.lineTo(s*2,s);context.lineTo(s,s*2);context.lineTo(0,s);context.lineTo(-s,s*2);context.lineTo(-s*2,s);context.lineTo(-s,0);context.lineTo(-s*2,-s);context.lineTo(-s,-s*2);context.lineTo(0,-s);context.lineTo(s,-s*2);context.lineTo(s*2,-s);context.closePath();}};/*\n      //foreshadowing symbol\n      const fsSymbol = {\n        draw: (context, size) => {\n          let s = size;\n              context.moveTo(0,0);\n              context.lineTo(s*2,s/2);\n              context.lineTo(s*2,-s/2);\n              context.closePath();\n        }\n      };\n      //foreshadowing gradient\n      var fsg = svg.append(\"defs\").append(\"linearGradient\")\n      .attr(\"id\", \"fsgradient\")//id of the gradient\n      .attr(\"x1\", \"0%\")\n      .attr(\"x2\", \"100%\") //since its a horizontal linear gradient\n      .attr(\"y1\", \"0%\")\n      .attr(\"y2\", \"0%\");\n\n      fsg.append(\"stop\")\n      .attr(\"offset\", \"0%\")\n      .style(\"stop-color\", \"black\")//start in black. TODO: different color foreshadowing\n      .style(\"stop-opacity\", 1);\n\n      fsg.append(\"stop\")\n      .attr(\"offset\", \"100%\")\n      .style(\"stop-color\", \"black\")//end in transparent\n      .style(\"stop-opacity\", 0);\n*/ //---draw symbols---//\n//TODO: doesn't display if cancelled is true from the start\n// .attr(\"cx\", ([,v]) => xScales[v.scale[0]].scale(v.x)) //scale x coordinate based on xScale defined in instant's scale property\n// .attr(\"cy\", ([,v]) => yScale(v.y))\nsvg.selectAll(\".cancelled\").data(activeData.filter(function(_ref40){var _ref41=_slicedToArray(_ref40,2),v=_ref41[1];return v.cancelled;})).join(\"path\").raise().attr(\"class\",\"cancelled pointer\").attr(\"d\",symbol(cancelledSymbol,radius*radius*5)).attr(\"fill\",function(_ref42){var _ref43=_slicedToArray(_ref42,2),v=_ref43[1];return v.color?v.color:\"black\";})//if it has a color other than black, use that\n.attr(\"transform\",function(_ref44){var _ref45=_slicedToArray(_ref44,2),v=_ref45[1];return\"translate(\".concat(xScales[v.scale[0]].scale(v.x),\", \").concat(yScale(v.y),\")\");}).on(\"click\",function(e,target){if(toggle===\"cancelled\"){var newData=_objectSpread({},data);newData[target[0]].cancelled=false;updateSrc(newData);}else{setInfo({position:[e.x,e.y],target:target});//displays instant properties when clicked\n}e.stopPropagation();});/*\n      //---draw foreshadowing---//\n      svg\n        .selectAll(\".foreshadowing\")\n        .data(activeData.filter(d => d.foreshadowing))\n        .join(\"path\")\n        .raise()\n        .attr(\"class\", \"foreshadowing pointer\")\n        .attr(\"d\", symbol(fsSymbol, radius*radius*5))\n        .style(\"fill\", \"url(#fsgradient)\")\n        .attr(\"transform\", d => `translate(${xScales[d.scale].scale(d.x)}, ${yScale(d.y)})`)\n        .on(\"click\", (e, target) => {\n          if (toggle===\"foreshadowing\") {\n            const newInstants = [...data];\n            const instant = newInstants.find(n => n.id === target.id);\n            delete instant.foreshadowing;\n            setData(newInstants);\n          } else {\n            setInfo({position: [e.x, e.y], target: target}); //displays instant properties when clicked\n          }\n          e.stopPropagation();\n        });\n*/ //---draw labels---//\n// svg\n//   .selectAll(\".zoneLabel\")\n//   .data(zones)\n//   .join(\"text\")\n//   .attr(\"class\", \"zoneLabel\")\n//   .text(v => v.text)\n//   .attr(\"x\", v => xScales[v.scale].scale(v.start))\n//   .attr(\"y\", v => yScale(v.yStart?v.yStart:yMin+5))\n//   .attr(\"text-anchor\", \"middle\");\nsvg.selectAll(\".label\").data(activeData.filter(function(_ref46){var _ref47=_slicedToArray(_ref46,2),v=_ref47[1];return!isNaN(v.x);})).join(\"text\").attr(\"class\",\"label\").text(function(_ref48){var _ref49=_slicedToArray(_ref48,2),k=_ref49[0],v=_ref49[1];return showLabel?v.text:v.id;}).attr(\"x\",function(_ref50){var _ref51=_slicedToArray(_ref50,2),k=_ref51[0],v=_ref51[1];return xScales[v.scale[0]].scale(v.x);}).attr(\"y\",function(_ref52){var _ref53=_slicedToArray(_ref52,2),k=_ref53[0],v=_ref53[1];return yScale(v.y-0.05*rangeY);})//vertical offset. see scales\n.attr(\"text-anchor\",\"middle\");// .attr(\"font-size\", fontSize);\nsvg.selectAll(\".intervalLabel\").data(intervals).join(\"text\").attr(\"class\",\"intervalLabel\").text(function(v){return v.text;}).attr(\"x\",function(v){var source=v.source[1];var target=v.target[1];if(!isNaN(source.x)&&!isNaN(target.x)){//scale values, then average them\nreturn(xScales[source.scale[0]].scale(source.x)+xScales[target.scale[0]].scale(target.x))/2;}else if(isNaN(source.x)){var s=source.x===\"noBeginning\"?xScales[source.scale[0]].noBeginning:xScales[source.scale[0]].noEnd;return(s+xScales[target.scale[0]].scale(target.x))/2;}else if(isNaN(target.x)){var _s=target.x===\"noBeginning\"?xScales[target.scale[0]].noBeginning:xScales[target.scale[0]].noEnd;return(_s+xScales[source.scale[0]].scale(source.x))/2;}}).attr(\"y\",function(v){return yScale(Math.min(v.source[1].y,v.target[1].y)-0.05*rangeY);})//.6 below lowest y, otherwise 1/5 of breakpoint\n.attr(\"text-anchor\",\"middle\");}//---zoom---//\nvar zoomBehavior=zoom().scaleExtent([1,5])//can zoom 2x smaller and 5x bigger\n.translateExtent([[-50,0],[dimensions.width+50,dimensions.height]])//limits how far graph can pan\n.on(\"zoom\",function(e){var zoomState=e.transform;//returns zoom transformations as an object\nsetCurrentZoomState(zoomState);});//regular clicking\nsvg.on(\"click\",function(e){if(toggle===\"addInstant\"){/*\n        if range of zoom > 10, Math.round(x)\n        if range of zoom <= 10 (floor: 10^0, ceiling: 10^1), use tenths (/10 -> /10^1)\n        if range of zoom <= 1 (floor: 10^-1, ceiling: 10^0), use hudredths (/100 -> (10^2))\n        if range of zoom <= .1 (floor: 10^-2, ceiling: 10^-1), use thousandths (/1000 -> (10^-3), etc.\n        const decimal = scales[activeScale]\n        xScales[key].scale\n        const decimal = scales[activeScale]\n        */ //TODO: zoom range matches up with current zoom\nvar zoomRange=xScales[activeScale[0]].scale.domain()[1]-xScales[activeScale[0]].scale.domain()[0];//max-min\n// const precision = Math.log10(zoomRange)<1 ? -(Math.floor(Math.log10(zoomRange)-1)) : 0;\nvar x=xScales[activeScale[0]].scale.invert(e.layerX);var y=yScale.invert(e.layerY);// console.log(Math.round(x*Math.pow(10, precision))/ Math.pow(10, precision));\nsetInflectTarget({x:round(x,zoomRange),y:Math.round(y)});setToggle(\"NewInstantForm\");}setInfo(null);});svg.call(zoomBehavior);},[data,setData,zones,scales,toggle,activeLayer,activeData,dimensions,logic,currentZoomState,setInfo,radius,showLabel,syntacticOrder]);return/*#__PURE__*/_jsx(\"div\",{ref:wrapperRef,className:\"svgWrapper\",children:/*#__PURE__*/_jsx(\"svg\",{id:\"graphic\",ref:svgRef})});};export default Graphic;","map":{"version":3,"sources":["/Users/skye/Desktop/Portfolio/chronovis/src/components/Graphic.js"],"names":["React","useState","useEffect","useRef","select","scaleLinear","scaleOrdinal","axisBottom","axisLeft","linkHorizontal","format","drag","zoom","min","max","symbol","symbols","useResizeObserver","generateIntervals","Graphic","data","setData","updateSrc","activeLayer","zones","setZones","radius","info","setInfo","setInflectTarget","showLabel","toggle","setToggle","scales","setScales","syntacticOrder","setSyntacticOrder","activeScale","activeData","Object","entries","activeZones","logic","length","isNaN","x","svgRef","wrapperRef","dimensions","currentZoomState","setCurrentZoomState","yScales","yTicks","v","push","y","forEach","k","scale","domain","height","range","ticks","Set","intervals","svg","current","selectAll","remove","round","value","precision","Math","log10","floor","pow","logicScale","unknown","breakpoint","xMin","map","key","xMax","yMin","yMax","rangeX","rangeY","xInverse","currentScale","width","xDrag","xScales","fromEntries","thisScale","noBeginning","noEnd","hasSegments","segments","hideLabel","yPos","label","units","tickValues","scaleInverse","xSegments","keys","i","n","proportion","segment","newXScale","rescaleX","newMin","newMax","yScale","yScaleInverse","yScaleInverseDrag","join","attr","start","end","opacity","color","importance","on","e","target","position","type","stopPropagation","tickSize","append","style","call","raise","g","d","xAxis","concat","tickFormat","hideUnits","text","yAxis","hideLabels","dragged","dx","subject","dy","newInstants","console","log","intervaler","source","interval","dashed","newOrder","layerX","layerY","newData","cancelled","instant","find","id","foreshadowing","cancelledSymbol","draw","context","size","s","sqrt","moveTo","lineTo","closePath","filter","zoomBehavior","scaleExtent","translateExtent","zoomState","transform","zoomRange","invert"],"mappings":"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O,CAAE;AACPC,OAAO,CAACC,GAAR,CAAY,WAAZ,EACD,CACD,MACF,IAAK,WAAL,CACEzH,gBAAgB,CAACiG,MAAD,CAAhB,CACA,MACF,IAAK,YAAL,CACEjG,gBAAgB,CAACiG,MAAD,CAAhB,CACA,MACF,QACElG,OAAO,CAAC,IAAD,CAAP,CAAe;AACfA,OAAO,CAAC,CAACmG,QAAQ,CAAE,CAACF,CAAC,CAAChF,CAAH,CAAMgF,CAAC,CAACtE,CAAR,CAAX,CAAuBuE,MAAM,CAAEA,MAA/B,CAAD,CAAP,CAAiD;AApCrD,CAsCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAD,CAAC,CAACI,eAAF,GAAqB;AACtB,CA7FH,EA+FA;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAxMqC,CAyM/B;AACA,GAAMmC,CAAAA,eAAe,CAAG,CACtBC,IAAI,CAAE,cAACC,OAAD,CAAUC,IAAV,CAAmB,CACvB,GAAIC,CAAAA,CAAC,CAAGhG,IAAI,CAACiG,IAAL,CAAUF,IAAV,EAAgB,CAAxB,CACID,OAAO,CAACI,MAAR,CAAeF,CAAf,CAAiB,CAAjB,EACAF,OAAO,CAACK,MAAR,CAAeH,CAAC,CAAC,CAAjB,CAAmBA,CAAnB,EACAF,OAAO,CAACK,MAAR,CAAeH,CAAf,CAAiBA,CAAC,CAAC,CAAnB,EACAF,OAAO,CAACK,MAAR,CAAe,CAAf,CAAiBH,CAAjB,EACAF,OAAO,CAACK,MAAR,CAAe,CAACH,CAAhB,CAAkBA,CAAC,CAAC,CAApB,EACAF,OAAO,CAACK,MAAR,CAAe,CAACH,CAAD,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","sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\nimport { select, scaleLinear, scaleOrdinal, axisBottom, axisLeft, linkHorizontal, format, drag, zoom, min, max, symbol, symbols } from \"d3\";\nimport useResizeObserver from \"./useResizeObserver\";\nimport generateIntervals from \"./generateIntervals\";\n\nfunction Graphic({\n  data, setData,\n  updateSrc,\n  activeLayer,\n  zones, setZones,\n  radius,\n  info, setInfo,\n  setInflectTarget,\n  showLabel,\n  toggle, setToggle,\n  scales, setScales,\n  syntacticOrder, setSyntacticOrder,\n  activeScale\n}) {\n\n  //all data is passed down from and synced to App.js\n  const activeData = Object.entries(data); //convert json to array for faster processing\n  const activeZones = Object.entries(zones);\n  //TODO: layers\n  // const activeData = activeLayer ? Object.entries(data).filter(([k,v]) => v.layer === activeLayer) : arrayData;\n\n  //convert scale object to array for faster processing\n\n\n  //is logical operators active?\n  const logic = data.length? isNaN(data[0].x): null; //TODO: refine logical operators\n\n  //initialize reference object to pass to svg in React Dom\n  const svgRef = useRef();\n  //svg wrapped in div bc otherwise resize observer callback won't work\n  const wrapperRef = useRef();\n  const dimensions = useResizeObserver(wrapperRef);\n  const [currentZoomState, setCurrentZoomState] = useState();\n\n  //hash map of y scales\n  const yScales = {};\n\n  //init scales\n  useEffect(() => {\n    if (!dimensions) return;\n    const yTicks = [];\n\n    for (let v of activeData) {\n      yTicks.push(activeData.y);\n    }\n\n    Object.entries(scales.y).forEach(([k, v]) => {\n      yScales[k]= {\n        scale: scaleLinear()\n        .domain([0, dimensions.height])\n        .range([v.min, v.max]),\n        drag: scaleLinear()\n        .domain([-dimensions.height, dimensions.height])\n        .range([-(v.max-v.min), (v.max-v.min)]),\n        ticks: [...new Set(yTicks)]\n      }\n    });\n  }, [dimensions, scales, currentZoomState]);\n\n  //initialize intervals between instants\n  const intervals = generateIntervals(data); //TODO: write updateIntervals function\n\n  //initialize variables\n  /*\n  var xMin = min(Object.entries(data).map(([key, {x}]) => logic ? logicScale(x) : x));\n  var xMax = max(Object.entries(data).map(([key, {x}]) => logic ? logicScale(x) : x));\n  var yMin = min(Object.entries(data).map(([key, {y}]) => y));\n  var yMax = max(Object.entries(data).map(([key, {y}]) => y));\n  */\n\n  //all d3 shennanigans goes in this hook. called initially and on every data change\n  useEffect(() => {\n    const svg = select(svgRef.current); //\"svg\" is the current version of svgRef data\n    //prevents crashing when useResizeObserver returns null before svg is rendered\n    if (!dimensions) return;\n    //removes svgs added using append()\n    svg\n      .selectAll(\".remove\")\n      .remove();\n\n    //rounding for data inputted thru paintbox interface\n    function round(value, range) {\n      const precision = Math.log10(range)<1 ? -(Math.floor(Math.log10(range)-1)) : 0;\n      return Math.round(value*Math.pow(10, precision))/ Math.pow(10, precision)\n    }\n\n\n    //---scales---//\n\n    //if time matches logical operator keyword, translate into index values, then map\n    const logicScale = scaleOrdinal([\"before\", \"now\", \"after\"], [-1, 0, 1]).unknown(0);\n\n    const breakpoint = 5;\n\n\n    const xMin = min(activeData.map(([key, {x}]) => logic ? logicScale(x) : x));\n    const xMax = max(activeData.map(([key, {x}]) => logic ? logicScale(x) : x));\n    // const yMin = min(Object.entries(data).map(([key, {y}]) => y));\n    // const yMax = max(Object.entries(data).map(([key, {y}]) => y));\n    const yTicks = activeData.map(([,{y}]) => y);\n    const yMin = scales.y[activeScale[1]].min;\n    const yMax = scales.y[activeScale[1]].max;\n    const rangeX = xMax-xMin; //0 is minX, 1 is maxX (reference findMinMax)\n    const rangeY = yMax-yMin;\n\n\n    /*\n    - Allow users to specify scale. x&y min max and units label\n    - for each scale, generateScale()\n    */\n\n    // function generateScales(currentScale) { //TODO: turn into dedicated scaleDrag\n    //\n    //   const xInverse = scaleLinear()\n    //     .domain([0, dimensions.width])\n    //     .range([currentScale.min, currentScale.max]) //maxRangeX-minRangeX gives section of x values displayed onscreen\n    //   const xDrag = scaleLinear()\n    //     .domain([-dimensions.width, dimensions.width])\n    //     .range([-(currentScale.domain()[1]-currentScale.domain()[0]), (currentScale.domain()[1]-currentScale.domain()[0])]) //maxRangeX-minRangeX gives section of x values displayed onscreen\n    //   const yInverse = scaleLinear()\n    //     .domain([-dimensions.height, dimensions.height])\n    //     .range((rangeY>breakpoint) ? [-rangeY, rangeY] : [-breakpoint*5, breakpoint*5])\n    //\n    //\n    //   return {\n    //     xInverse, xDrag, yInverse\n    //   };\n    // }\n    const xInverse = (currentScale) => scaleLinear()\n      .domain([0, dimensions.width])\n      .range([currentScale.min, currentScale.max]) //maxRangeX-minRangeX gives section of x values displayed onscreen\n    const xDrag = (currentScale) => scaleLinear()\n      .domain([-dimensions.width, dimensions.width])\n      .range([-(currentScale.domain()[1]-currentScale.domain()[0]), (currentScale.domain()[1]-currentScale.domain()[0])]) //maxRangeX-minRangeX gives section of x values displayed onscreen\n    // const yInverse = scaleLinear()\n    //   .domain([-dimensions.height, dimensions.height])\n    //   .range((rangeY>breakpoint) ? [-rangeY, rangeY] : [-breakpoint*5, breakpoint*5])\n\n\n    //scales values to screen pixels\n    /*\n    {\n      biggie: {\n        ...\n        scale: generateScale()\n      }\n      ...\n    }\n    */\n\n    /*\n    xScale =\n    {\n\n  }\n    */\n\n\n    //TODO: fromEntries & entries not compatible with some older browsers\n    const xScales = Object.fromEntries( //for every scale in scales data, generate an xScale\n      Object.entries(scales.x).map(([key, thisScale]) => [\n        key,\n        {\n          scale: scaleLinear() //scaleLinear takes domain (data values) & maps onto range (screen pixel values)\n            .domain([thisScale.min, thisScale.max])\n            .range([0, dimensions.width]),\n          noBeginning: thisScale.min-10,\n          noEnd: thisScale.max+10,\n          hasSegments: thisScale.segments.length?true:false,\n          hideLabel: thisScale.hideLabel,\n          yPos: thisScale.yPos,\n          label: `${key} (${thisScale.units})`,\n          tickValues: thisScale.tickValues?thisScale.tickValues:null,\n          scaleInverse: scaleLinear() //for NewInstantForm\n            .domain([0, dimensions.width])\n            .range([thisScale.min, thisScale.max])\n        }\n      ])\n    );\n\n\n    const xSegments = () => {\n      const segments = [];\n      Object.keys(scales.x).forEach((key, i) => {\n        const thisScale = scales.x[key];\n        // const segments = [];\n        if (!thisScale.segments.length) {\n          return;\n        }\n        thisScale.segments.map(n => {\n          const min = n.min?n.min:thisScale.min; //if segment contains a min, set that as min. otherwise, set scale min as min.\n          const max = n.max?n.max:thisScale.max;\n          // console.log(xScales[i].scale(min));\n          segments.push({\n            scale: key,\n            yPos: thisScale.yPos,\n            proportion: (max-min)/(thisScale.max-thisScale.min),\n            segment: scaleLinear()\n            .domain([min, max])\n            .range([xScales[key].scale(min), xScales[key].scale(max)])\n          })\n        })\n      });\n      return segments;\n    }\n\n\n    /*\n      xScales(generateScales(scaleLinear(scale)))\n      - take xScale and rescale according to transformations (newXScale)\n      - update each array entry's domain with that of newXScale\n    */\n    //if there is a zoom transform, override each xScales.scale with adjusted scale\n    if (currentZoomState) {\n      Object.entries(xScales).forEach(([key,thisScale]) => {\n        const newXScale = currentZoomState.rescaleX(thisScale.scale); //zoom state comes w methods for transformations\n        const newMin = newXScale.domain()[0]\n        const newMax = newXScale.domain()[1];\n\n        //applies zoom transformations to scale + scaleInverse\n        xScales[key].scale = newXScale;\n      });\n\n\n    };\n    // const xScale = scaleLinear()\n    //   .domain([xMin, xMax]) //scaleLinear takes domain (data values) & maps onto range (screen pixel values)\n    //   .range([0, dimensions.width]);\n    const yScale = scaleLinear()\n      //if difference in y vaules greater than 5, resize to min and max\n      // .domain((rangeY>breakpoint) ? [yMin, yMax] : [yMin-breakpoint, yMax+breakpoint])\n      .domain([yMin, yMax])\n      .range([dimensions.height,0]);\n    //inverse scales for drag behavior\n    // const xScaleInverse = scaleLinear()\n    //   .domain([-dimensions.width, dimensions.width])\n    //   .range([-rangeX, rangeX]); //maxRangeX-minRangeX gives section of x values displayed onscreen\n    const yScaleInverse = scaleLinear()\n      .domain([0, dimensions.height])\n      .range([yMin, yMax])\n      // .range((rangeY>breakpoint) ? [yMin, yMax] : [yMin-breakpoint, yMax+breakpoint]);\n    const yScaleInverseDrag = scaleLinear()\n      .domain([dimensions.height, -dimensions.height])\n      .range([-rangeY, rangeY])\n      // .range((rangeY>breakpoint) ? [-rangeY, rangeY] : [-breakpoint*5, breakpoint*5]);\n\n\n\n\n\n\n    //---draw zones---//\n    if (activeZones.length) {\n      svg\n      .selectAll(\".zones\")\n      .data(activeZones)\n      .join(\"rect\")\n      .attr(\"class\", \"zones\")\n      .attr(\"x\", ([, v]) => xScales[v.scale[0]].scale(v.start))\n      // .attr(\"x\", n => generateScales(scales[n.scale]).x(n.start))\n      .attr(\"y\", ([, v]) => yScale(yMax))\n      // .attr(\"y\", ([, v]) => v.yStart ? yScale(v.yStart) : yMin-10) //TODO: if no yStart, minimum y value\n      .attr(\"width\", ([, v]) => xScales[v.scale[0]].scale(v.end) - xScales[v.scale[0]].scale(v.start))\n      .attr(\"height\", ([, v]) => {\n        return (yScale(yMin))\n        // if (v.yStart & v.yEnd) {\n        //   return (yScale(v.yStart)-yScale(v.yEnd))\n        // } else if (v.yStart) {\n        //   return (yScale(v.yStart)-yScale(yMax-10))\n        // } else {\n        //   return (yScale(yMax-10)) //TODO: if no yStart, minimum y value\n        //   // return (yScale(minMax[3])-yScale(minMax[2]))\n        // }\n      })\n      .attr(\"opacity\", ([k, v]) => v.opacity ? v.opacity : 0.5)\n      .attr(\"fill\", ([k, v]) => v.color ? v.color : \"#999\")\n      .attr(\"stroke\", \"black\") //TODO: stroke be different colors\n      .attr(\"stroke-width\", ([k, v]) => v.importance ? v.importance*2 : 0)\n      .on(\"click\", (e, target) => {\n        if (toggle===\"certainty\" || toggle===\"importance\") { //pulls up inflection menu\n          setInflectTarget(target);\n        } else { //displays zone properties when clicked\n          setInfo(null); //clear InfoBox\n          setInfo({position: [e.x, e.y], target: target, type: \"zone\"});  //TODO: set info to null when clicking same zone again\n        }\n        e.stopPropagation();\n      });\n    }\n\n    //---draw bottom axis---//\n\n    xSegments().forEach(n => {\n      //TODO: push all the axis ticks() values into an array\n      // [...new Set(segments)]\n      //draw from there\n      const segment = axisBottom(n.segment)\n      // .ticks(n.proportion<.33?5:null, \"f\");\n      .ticks(null, \"f\")\n      .tickSize(-dimensions.height); //TODO\n\n      svg\n        .append(\"g\")\n        .attr(\"class\", \"remove\")\n        .style(\"transform\", `translateY(${dimensions.height*n.yPos}px)`)\n        .call(segment)\n        .raise()\n        .call(g => g.select(\".domain\") //removes solid black axis bar\n          .remove())\n        .call(g => g.selectAll(\".tick line\") //styles individual ticks\n          .attr(\"stroke-opacity\", 0.25))\n        .call(g => g.selectAll(\".tick text\")\n          .attr(\"y\", 10)\n          .attr(\"opacity\", (d, i) => { //TODO: remove instead of setting opacity to 0\n            if ((n.proportion<.25)&&(i%3)) { //less than 1/4, label every 3 ticks\n              return 0;\n            } else if ((n.proportion<.33)&&(i%2)) { //less than 1/3, label every other tick\n              return 0;\n            } else {\n              return 0.5\n            }\n          })\n        );\n    });\n\n    Object.entries(xScales).forEach(([key,thisScale]) => {\n      const xAxis = axisBottom(thisScale.scale)\n      .tickValues(thisScale.scale.ticks().concat(scales.x[key].min, scales.x[key].max)) //pass in autogenerated tick values + min and max values\n      .tickFormat(format(''))\n      .tickSize(-dimensions.height);\n      // console.log(thisScale.scale.ticks())\n\n      if (!thisScale.hasSegments) {\n        svg\n          .append(\"g\")\n          .attr(\"class\", \"remove\")\n          .style(\"transform\", `translateY(${dimensions.height*thisScale.yPos}px)`)\n          .call(xAxis)\n          .raise()\n          .call(g => g.select(\".domain\") //removes solid black axis bar\n            .remove())\n          .call(g => g.selectAll(\".tick line\") //styles individual ticks\n            .attr(\"stroke-opacity\", 0.25))\n          .call(g => g.selectAll(\".tick text\")\n            .attr(\"y\", 10) //TODO: dynamic tick text spacing for accessibility\n            .attr(\"opacity\", 0.5));\n      }\n      if (!thisScale.hideUnits) {\n        svg\n          .append(\"text\")\n          .text(thisScale.label)\n          .attr(\"class\", \"axisLabel smallTxt remove\")\n          .attr(\"x\", dimensions.width/2)\n          .attr(\"y\", dimensions.height*(thisScale.yPos+.07))\n          .attr(\"text-anchor\", \"middle\")\n          .attr(\"opacity\", 0.5);\n        }\n      }\n\n    );\n\n    //--draw vertical axis--//\n\n    const yAxis = axisLeft(yScale)\n    .tickValues([...new Set(yTicks), scales.y[activeScale[1]].min, scales.y[activeScale[1]].max]) //reg mode\n    .tickFormat(format(''))\n\n    svg\n      .append(\"g\")\n      .attr(\"class\", \"remove\")\n      // .style(\"transform\", `translateY(${dimensions.height*thisScale.yPos}px)`)\n      .call(yAxis)\n      .raise()\n      .call(g => g.select(\".domain\") //removes solid black axis bar\n        .remove())\n      .call(g => g.selectAll(\".tick line\") //styles individual ticks\n        .attr(\"stroke-opacity\", 0.5))\n      .call(g => g.selectAll(\".tick text\")\n        .attr(\"y\", 10) //TODO: dynamic tick text spacing for accessibility\n        .attr(\"opacity\", 0.5));\n\n    if (!scales.y[activeScale[1]].hideLabels) {\n      svg\n        .append(\"text\")\n        .text(`${activeScale[1]} (${scales.y[activeScale[1]].units})`)\n        .attr(\"class\", \"axisLabel smallTxt remove\")\n        // .attr(\"x\", dimensions.width/2)\n        // .attr(\"y\", dimensions.height/2)\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"transform\", `translate(-30,${dimensions.height/2})rotate(-90)`)\n        .attr(\"opacity\", 0.5);\n    }\n\n    //--drag behavior--//\n    const dragged = drag()\n      // .on(\"start\", e => {\n      //   select(this).attr(\"stroke\", \"black\");\n      // })\n      .on(\"drag\", e => {\n        //TODO: extract precision function to round new pos\n        const dx = xDrag(xScales[e.subject[1].scale[0]].scale)(e.dx);\n        // const dx = xScales.scaleInverse\n        const dy = yScaleInverseDrag(e.dy);\n        const newInstants = {...data}; //always make a copy when updating array\n\n        //find array element in data with matching ID and set new x y coordinates\n        newInstants[e.subject[0]].x += dx;\n        newInstants[e.subject[0]].y += dy;\n\n        setData(newInstants);\n      }) //TODO: unify onEnd and onClick\n      .on(\"end\", e => {\n        console.log(\"end\");\n      });\n\n    if (Object.entries(data).length) {\n      //---draw intervals---//\n      const intervaler = linkHorizontal()\n        .source(interval => interval.source[1])\n        .target(interval => interval.target[1])\n        // .x(n => generateScales(scales[n.scale]).x(logic ? logicScale(n.x) : n.x))\n        .x(v => {\n            if (!isNaN(v.x)) {\n              return xScales[v.scale[0]].scale(v.x)\n            } else if (v.x===\"noEnd\") {\n              return xScales[v.scale[0]].noEnd\n            } else if (v.x===\"noBeginning\") {\n              return xScales[v.scale[0]].noBeginning\n            }\n        })\n        .y(v => yScale(v.y));\n\n      svg\n        .selectAll(\".interval\")\n        .data(intervals)\n        .join(\"path\")\n        .raise()\n        .attr(\"class\", \"interval pointer\")\n        .attr(\"d\", intervaler)\n        .attr(\"fill\", \"none\")\n        .attr(\"stroke\", n => n.color? n.color : \"black\")\n        .attr(\"stroke-width\", n => n.width ? n.width : radius)\n        .attr(\"stroke-opacity\", n => n.opacity ? n.opacity : 1)\n        .attr(\"stroke-dasharray\", n => n.dashed ? n.dashed : null)\n        .on(\"click\", (e, target) => {\n          if (toggle===\"connection\") {\n            const newOrder = [...syntacticOrder];\n            if (newOrder[2]===0) { //set 2nd selection\n              newOrder[1] = {x:xInverse(scales.x[activeScale[0]])(e.layerX), y:yScaleInverse(e.layerY), scale:activeScale}; //scale TODO\n              newOrder[2] = 1;\n            } else { //set 1st selection\n              newOrder[0] = {x:xInverse(scales.x[activeScale[0]])(e.layerX), y:yScaleInverse(e.layerY), scale:activeScale};\n              newOrder[2] = 0;\n            }\n            setSyntacticOrder(newOrder);\n          }\n          //else if (toggle===\"foreshadowing\") {\n          //   if (!target.target) { //if target is an endpoint, indeterminate end\n          //\n          //\n          //   } else { //otherwise, change mouse to no symbol\n          //\n          //   }\n          //   //option to adjust gradient eventually\n          // } else\n          else if (toggle===\"certainty\" || toggle===\"importance\") {\n            setInflectTarget(target);\n          } else {\n            setInfo(null); //clear InfoBox\n            setInfo({position: [e.x, e.y], target: target, type: \"interval\"}); //displays interval properties when clicked\n          }\n          e.stopPropagation();\n        });\n\n\n\n      //---draw instants---//\n      svg\n        .selectAll(\".instant\")\n        // .data(activeData.filter(d => !d.foreshadowing && !d.cancelled))\n        .data(activeData)\n        .join(\"circle\")\n        .raise()\n        .attr(\"class\", \"instant pointer\")\n        .attr(\"r\", ([,v]) => v.radius? v.radius : radius) //TODO: custom radius accessibility\n        .attr(\"fill\", ([,v]) => v.color ? v.color : \"black\") //if it has a color other than black, use that\n        .attr(\"opacity\", ([,v]) => v.opacity ? v.opacity : 1)\n        // .attr(\"cx\", d => generateScales(scales[d.scale]).x(logic ? logicScale(d.x) : d.x))\n        .attr(\"cx\", ([,v]) => {\n          if (!isNaN(v.x)) {\n            return xScales[v.scale[0]].scale(v.x)\n          } else if (v.x===\"noBeginning\"){\n            return xScales[v.scale[0]].noBeginning\n          } else if (v.x===\"noEnd\") {\n            return xScales[v.scale[0]].noEnd\n          }\n        }) //scale x coordinate based on xScale defined in instant's scale property\n        .attr(\"cy\", ([,v]) => yScale(v.y))\n        .call(dragged)\n        .on(\"click\", (e, target) => {\n          switch (toggle) {\n            case \"cancelled\":\n              const newData = {...data};\n              newData[target[0]].cancelled = true;\n              // console.log(newData[target[0]]);\n              updateSrc(newData);\n              break;\n            case \"connection\":\n              const newOrder = [...syntacticOrder];\n              if (newOrder[2]===0) { //set 2nd selection\n                newOrder[1] = target;\n                newOrder[2] = 1;\n              } else { //set 1st selection\n                newOrder[0] = target;\n                newOrder[2] = 0;\n              }\n              setSyntacticOrder(newOrder);\n              break;\n            case \"foreshadowing\":\n              if (!target.target) { //if target is an endpoint, indeterminate end\n                const newInstants = [...data];\n                const instant = newInstants.find(n => n.id === target.id);\n                instant.foreshadowing = true;\n                setData(newInstants);\n              } else { //otherwise, change mouse to no symbol\n                console.log(\"forbidden\");\n              }\n              break;\n            case \"certainty\":\n              setInflectTarget(target);\n              break;\n            case \"importance\":\n              setInflectTarget(target);\n              break;\n            default:\n              setInfo(null); //clear InfoBox\n              setInfo({position: [e.x, e.y], target: target}); //displays instant properties when clicked\n          }\n          // if (toggle===\"cancelled\") {\n          //   const newInstants = [...data];\n          //   const instant = newInstants.find(n => n.id === target.id);\n          //   instant.cancelled = true;\n          //   setData(newInstants);\n          // } else if (){\n          //\n          // } else if (toggle===\"connection\") {\n          //   const newOrder = [...syntacticOrder];\n          //   if (newOrder[2]===0) { //set 2nd selection\n          //     newOrder[1] = target;\n          //     newOrder[2] = 1;\n          //   } else { //set 1st selection\n          //     newOrder[0] = target;\n          //     newOrder[2] = 0;\n          //   }\n          //   setSyntacticOrder(newOrder);\n          // } else if (toggle===\"foreshadowing\") { //todo: adjust gradient\n          //   if (!target.target) { //if target is an endpoint, indeterminate end\n          //     const newInstants = [...data];\n          //     const instant = newInstants.find(n => n.id === target.id);\n          //     instant.foreshadowing = true;\n          //     setData(newInstants);\n          //   } else { //otherwise, change mouse to no symbol\n          //     console.log(\"forbidden\");\n          //   }\n          // } else if (toggle===\"certainty\" || toggle===\"importance\"){\n          //   setInflectTarget(target);\n          // } else {\n          //   setInfo({position: [e.x, e.y], target: target}); //displays instant properties when clicked\n          // }\n          e.stopPropagation(); //stops deselect when bg is clicked\n        });\n\n      /*//---draw inflections---//\n\n      //--draw connetion inflection--//\n      //circle around instant\n      svg\n        .selectAll(\".connections\")\n        .data(activeData.filter(d => d.connections))\n        .join(\"circle\")\n        .raise()\n        .attr(\"class\", \"connections pointer\")\n        .attr(\"r\", n => n.radius? n.radius*1.5 : radius*2) //TODO: custom radius accessibility\n        .attr(\"fill\", \"none\")\n        .attr(\"stroke\", \"black\")\n        .attr(\"stroke-dasharray\", \"3\")\n        // .attr(\"opacity\", d => d.opacity ? d.opacity : 1)\n        .attr(\"cx\", d => xScales[d.scale].scale(d.x)) //scale x coordinate based on xScale defined in instant's scale property\n        .attr(\"cy\", d => yScale(d.y));\n\n      //link connecting circles\n      const ctLinker = linkHorizontal()\n        .source(instant => data.find(x => x.id === instant.id))\n        .target(instant => typeof(instant.connections[0])===\"object\" ? instant.connections[0] : data.find(x => x.id === instant.connections[0]))\n        // .target(() => {\n        //   //layerX, layerY\n        //   const y = yScaleInverse(499);\n        //   const x = xScales.find(n => n.text === \"biggie\").scaleInverse(778)\n        //   return {x: x, y: y}\n        // })\n        // .target(instant => data.find(x => x.id === instant.connections[0]))\n        .x(d => d.scale ? xScales[d.scale].scale(d.x) : d.x)\n        .y(d => d.scale ? yScale(d.y) : d.y);\n      svg\n        .selectAll(\".connectionLinks\")\n        .data(activeData.filter(n => n.connections && !n.connections[1])) //link starts from 1st one\n        .join(\"path\")\n        .raise()\n        .attr(\"class\", \"connectionLinks pointer\")\n        .attr(\"d\", ctLinker)\n        .attr(\"fill\", \"none\")\n        .attr(\"stroke\", \"black\")\n        // .attr(\"stroke\", n => n.color? n.color : \"black\")\n        // .attr(\"stroke-opacity\", n => n.opacity ? n.opacity : 1)\n        .attr(\"stroke-dasharray\", \"3\")\n*/\n      //initialize custom symbols\n      const cancelledSymbol = {\n        draw: (context, size) => {\n          let s = Math.sqrt(size)/2;\n              context.moveTo(s,0);\n              context.lineTo(s*2,s);\n              context.lineTo(s,s*2);\n              context.lineTo(0,s);\n              context.lineTo(-s,s*2);\n              context.lineTo(-s*2,s);\n              context.lineTo(-s,0);\n              context.lineTo(-s*2,-s);\n              context.lineTo(-s,-s*2);\n              context.lineTo(0,-s);\n              context.lineTo(s,-s*2);\n              context.lineTo(s*2,-s);\n              context.closePath();\n        }\n      };\n      /*\n      //foreshadowing symbol\n      const fsSymbol = {\n        draw: (context, size) => {\n          let s = size;\n              context.moveTo(0,0);\n              context.lineTo(s*2,s/2);\n              context.lineTo(s*2,-s/2);\n              context.closePath();\n        }\n      };\n      //foreshadowing gradient\n      var fsg = svg.append(\"defs\").append(\"linearGradient\")\n      .attr(\"id\", \"fsgradient\")//id of the gradient\n      .attr(\"x1\", \"0%\")\n      .attr(\"x2\", \"100%\") //since its a horizontal linear gradient\n      .attr(\"y1\", \"0%\")\n      .attr(\"y2\", \"0%\");\n\n      fsg.append(\"stop\")\n      .attr(\"offset\", \"0%\")\n      .style(\"stop-color\", \"black\")//start in black. TODO: different color foreshadowing\n      .style(\"stop-opacity\", 1);\n\n      fsg.append(\"stop\")\n      .attr(\"offset\", \"100%\")\n      .style(\"stop-color\", \"black\")//end in transparent\n      .style(\"stop-opacity\", 0);\n*/\n      //---draw symbols---//\n      //TODO: doesn't display if cancelled is true from the start\n      // .attr(\"cx\", ([,v]) => xScales[v.scale[0]].scale(v.x)) //scale x coordinate based on xScale defined in instant's scale property\n      // .attr(\"cy\", ([,v]) => yScale(v.y))\n      svg\n        .selectAll(\".cancelled\")\n        .data(activeData.filter(([,v]) => v.cancelled))\n        .join(\"path\")\n        .raise()\n        .attr(\"class\", \"cancelled pointer\")\n        .attr(\"d\", symbol(cancelledSymbol, radius*radius*5))\n        .attr(\"fill\", ([,v]) => v.color ? v.color : \"black\") //if it has a color other than black, use that\n        .attr(\"transform\", ([,v]) => `translate(${xScales[v.scale[0]].scale(v.x)}, ${yScale(v.y)})`)\n        .on(\"click\", (e, target) => {\n          if (toggle===\"cancelled\") {\n            const newData = {...data};\n            newData[target[0]].cancelled = false;\n            updateSrc(newData);\n          } else {\n            setInfo({position: [e.x, e.y], target: target}); //displays instant properties when clicked\n          }\n          e.stopPropagation();\n        });\n/*\n      //---draw foreshadowing---//\n      svg\n        .selectAll(\".foreshadowing\")\n        .data(activeData.filter(d => d.foreshadowing))\n        .join(\"path\")\n        .raise()\n        .attr(\"class\", \"foreshadowing pointer\")\n        .attr(\"d\", symbol(fsSymbol, radius*radius*5))\n        .style(\"fill\", \"url(#fsgradient)\")\n        .attr(\"transform\", d => `translate(${xScales[d.scale].scale(d.x)}, ${yScale(d.y)})`)\n        .on(\"click\", (e, target) => {\n          if (toggle===\"foreshadowing\") {\n            const newInstants = [...data];\n            const instant = newInstants.find(n => n.id === target.id);\n            delete instant.foreshadowing;\n            setData(newInstants);\n          } else {\n            setInfo({position: [e.x, e.y], target: target}); //displays instant properties when clicked\n          }\n          e.stopPropagation();\n        });\n*/\n      //---draw labels---//\n      // svg\n      //   .selectAll(\".zoneLabel\")\n      //   .data(zones)\n      //   .join(\"text\")\n      //   .attr(\"class\", \"zoneLabel\")\n      //   .text(v => v.text)\n      //   .attr(\"x\", v => xScales[v.scale].scale(v.start))\n      //   .attr(\"y\", v => yScale(v.yStart?v.yStart:yMin+5))\n      //   .attr(\"text-anchor\", \"middle\");\n\n      svg\n        .selectAll(\".label\")\n        .data(activeData.filter(([,v]) => !isNaN(v.x)))\n        .join(\"text\")\n        .attr(\"class\", \"label\")\n        .text(([k,v]) => showLabel ? v.text : v.id)\n        .attr(\"x\", ([k,v]) => xScales[v.scale[0]].scale(v.x))\n        .attr(\"y\", ([k,v]) => yScale(v.y-0.05*rangeY)) //vertical offset. see scales\n        .attr(\"text-anchor\", \"middle\");\n        // .attr(\"font-size\", fontSize);\n\n      svg\n        .selectAll(\".intervalLabel\")\n        .data(intervals)\n        .join(\"text\")\n        .attr(\"class\", \"intervalLabel\")\n        .text(v => v.text)\n        .attr(\"x\", v => {\n          const source=v.source[1];\n          const target=v.target[1];\n          if (!isNaN(source.x) && !isNaN( target.x)) {\n            //scale values, then average them\n            return (xScales[source.scale[0]].scale(source.x)+xScales[target.scale[0]].scale(target.x))/2\n          } else if (isNaN(source.x)) {\n            const s = source.x===\"noBeginning\"?xScales[source.scale[0]].noBeginning:xScales[source.scale[0]].noEnd\n            return (s+xScales[target.scale[0]].scale(target.x))/2\n          } else if (isNaN(target.x)) {\n            const s = target.x===\"noBeginning\"?xScales[target.scale[0]].noBeginning:xScales[target.scale[0]].noEnd\n            return (s+xScales[source.scale[0]].scale(source.x))/2\n          }\n        })\n        .attr(\"y\", v => yScale(Math.min(v.source[1].y, v.target[1].y)-0.05*rangeY)) //.6 below lowest y, otherwise 1/5 of breakpoint\n        .attr(\"text-anchor\", \"middle\");\n\n    }\n\n\n\n    //---zoom---//\n    const zoomBehavior = zoom()\n      .scaleExtent([1, 5]) //can zoom 2x smaller and 5x bigger\n      .translateExtent([[-50, 0], [dimensions.width+50, dimensions.height]]) //limits how far graph can pan\n      .on(\"zoom\", e => {\n        const zoomState = e.transform; //returns zoom transformations as an object\n        setCurrentZoomState(zoomState);\n      });\n\n    //regular clicking\n    svg.on(\"click\", (e) => {\n      if (toggle===\"addInstant\") {\n        /*\n        if range of zoom > 10, Math.round(x)\n        if range of zoom <= 10 (floor: 10^0, ceiling: 10^1), use tenths (/10 -> /10^1)\n        if range of zoom <= 1 (floor: 10^-1, ceiling: 10^0), use hudredths (/100 -> (10^2))\n        if range of zoom <= .1 (floor: 10^-2, ceiling: 10^-1), use thousandths (/1000 -> (10^-3), etc.\n        const decimal = scales[activeScale]\n        xScales[key].scale\n        const decimal = scales[activeScale]\n        */\n        //TODO: zoom range matches up with current zoom\n        const zoomRange = xScales[activeScale[0]].scale.domain()[1] - xScales[activeScale[0]].scale.domain()[0]; //max-min\n        // const precision = Math.log10(zoomRange)<1 ? -(Math.floor(Math.log10(zoomRange)-1)) : 0;\n        const x = xScales[activeScale[0]].scale.invert(e.layerX);\n        const y = yScale.invert(e.layerY);\n        // console.log(Math.round(x*Math.pow(10, precision))/ Math.pow(10, precision));\n        setInflectTarget({x: round(x, zoomRange), y: Math.round(y)});\n        setToggle(\"NewInstantForm\");\n      }\n      setInfo(null);\n    });\n    svg.call(zoomBehavior);\n\n  }, [data, setData, zones, scales, toggle, activeLayer, activeData, dimensions, logic, currentZoomState, setInfo, radius, showLabel, syntacticOrder]);\n\n  return (\n    <div ref={wrapperRef} className=\"svgWrapper\">\n      <svg id=\"graphic\" ref={svgRef}>\n      </svg>\n    </div>\n  );\n};\n\n\nexport default Graphic;\n"]},"metadata":{},"sourceType":"module"}